[
    {
        "instruction": "Constructor to initialize an object of the ApiBuffer class. The device created by the WMX3Api object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "ApiBuffer (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of the ApiBuffer class based on an existing object of this class. ",
        "input": "",
        "output": "ApiBuffer (const ApiBuffer &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class. Also see Copy Operators.",
        "input": "",
        "output": "ApiBuffer & operator= (const ApiBuffer &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "ApiBuffer ()"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~ApiBuffer ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Create a memory space for use with the API buffer. This function must be called before the API buffer functions can be used.",
        "input": "",
        "output": "CreateApiBuffer (unsigned int channel, unsigned int size)"
    },
    {
        "instruction": "Create a memory space for use with the API buffer using the default memory size.",
        "input": "",
        "output": "CreateApiBuffer (unsigned int channel)"
    },
    {
        "instruction": "Create a memory space for use with the API buffer. The size of the memory space can be specified in one of several units. ",
        "input": "",
        "output": "CreateApiBuffer (unsigned int channel, unsigned int size, SizeUnit::T sizeUnit)"
    },
    {
        "instruction": "Close an API buffer memory space",
        "input": "",
        "output": "FreeApiBuffer (unsigned int channel)"
    },
    {
        "instruction": " Start recording APIs to the API buffer channel.  ",
        "input": "",
        "output": "StartRecordBufferChannel (unsigned int channel)"
    },
    {
        "instruction": "End recording APIs to the API buffer channel.",
        "input": "",
        "output": "EndRecordBufferChannel ()"
    },
    {
        "instruction": "Get the currently recording API buffer channel, if any",
        "input": "",
        "output": "GetRecordingBufferChannel (int *channel, unsigned char *enable)"
    },
    {
        "instruction": "Execute an API buffer. ",
        "input": "",
        "output": "Execute (unsigned int channel)"
    },
    {
        "instruction": "Halt an API buffer.",
        "input": "",
        "output": "Halt (unsigned int channel)"
    },
    {
        "instruction": "Clear an API buffer.",
        "input": "",
        "output": "Clear (unsigned int channel)"
    },
    {
        "instruction": "Rewind an API buffer.",
        "input": "",
        "output": "Rewind (unsigned int channel)"
    },
    {
        "instruction": "Execute multiple API buffer channels.",
        "input": "",
        "output": "ExecuteMultipleChannel (ApiBufferChannelSelection *pChannelSelection)"
    },
    {
        "instruction": "Halt multiple API buffer channels.",
        "input": "",
        "output": "HaltMultipleChannel (ApiBufferChannelSelection *pChannelSelection)"
    },
    {
        "instruction": "Clear multiple API buffer channels.",
        "input": "",
        "output": "ClearMultipleChannel (ApiBufferChannelSelection *pChannelSelection)"
    },
    {
        "instruction": "Rewind multiple API buffer channels. ",
        "input": "",
        "output": "RewindMultipleChannel (ApiBufferChannelSelection *pChannelSelection)"
    },
    {
        "instruction": "Get the current status of an API buffer. ",
        "input": "",
        "output": "GetStatus (unsigned int channel, ApiBufferStatus *pStatus)"
    },
    {
        "instruction": "Set options for an API buffer.",
        "input": "",
        "output": "SetOptions (unsigned int channel, ApiBufferOptions *pOptions)"
    },
    {
        "instruction": "Get the currently applied options for an API buffer.",
        "input": "",
        "output": "GetOptions (unsigned int channel, ApiBufferOptions *pOptions)"
    },
    {
        "instruction": "Set watch options for an API buffer. The watch function will stop the buffer execution when an error is detected.",
        "input": "",
        "output": "SetWatch (unsigned int channel, ApiBufferWatch *pWatch)"
    },
    {
        "instruction": "Get watch options for an API buffer. The watch function will stop the buffer execution when an error is detected.",
        "input": "",
        "output": "GetWatch (unsigned int channel, ApiBufferWatch *pWatch)"
    },
    {
        "instruction": "Add a sleep command to an API buffer.",
        "input": "",
        "output": "Sleep (unsigned int milliseconds)"
    },
    {
        "instruction": "Add a sleep command to an API buffer.",
        "input": "",
        "output": "USleep (unsigned int microseconds)"
    },
    {
        "instruction": "Add a wait command to an API buffer. ",
        "input": "",
        "output": "Wait (int axis)"
    },
    {
        "instruction": "Add a wait command to an API buffer.",
        "input": "",
        "output": "Wait (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Add a wait command to an API buffer.",
        "input": "",
        "output": "Wait (ApiBufferCondition *condition)"
    },
    {
        "instruction": "Add an \"If\" command to an API buffer.",
        "input": "",
        "output": "FlowIf (ApiBufferCondition *condition, ApiBufferCondition *wait=NULL)"
    },
    {
        "instruction": "Add an \"Else If\" command to an API buffer.",
        "input": "",
        "output": "FlowElseIf (ApiBufferCondition *condition)"
    },
    {
        "instruction": "Add an \"Else\" command to an API buffer. ",
        "input": "",
        "output": "FlowElse ()"
    },
    {
        "instruction": "Add an \"End If\" command to an API buffer.",
        "input": "",
        "output": "FlowEndIf ()"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code. ",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": " Get a string representation of the raw data of an API log.  ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the  CyclicBuffer object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "CyclicBuffer (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "CyclicBuffer (const CyclicBuffer &src) "
    },
    {
        "instruction": " Copy assignment operator to initialize an object of this class based on an existing object of this class.  ",
        "input": "",
        "output": "CyclicBuffer &  operator= (const CyclicBuffer &src) "
    },
    {
        "instruction": " Constructor to initialize an object of this class with a self device.  ",
        "input": "",
        "output": "CyclicBuffer () "
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~CyclicBuffer () "
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "bool  IsDeviceValid () "
    },
    {
        "instruction": "Get the version of the module rtdll. ",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Create a new cyclic buffer memory space for an axis.",
        "input": "",
        "output": "OpenCyclicBuffer (int axis, unsigned int numOfCycles)"
    },
    {
        "instruction": "Create a new cyclic buffer memory space for multiple axes.",
        "input": "",
        "output": "OpenCyclicBuffer (AxisSelection *pAxisSelection, unsigned int numOfCycles)"
    },
    {
        "instruction": "Close the cyclic buffer memory space of an axis.",
        "input": "",
        "output": "CloseCyclicBuffer (int axis)"
    },
    {
        "instruction": "Close the cyclic buffer memory space of multiple axes.",
        "input": "",
        "output": "CloseCyclicBuffer (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Add one position command data to the cyclic position command buffer of one axis. ",
        "input": "",
        "output": "AddCommand (int axis, CyclicBufferSingleAxisCommand *pCmd)"
    },
    {
        "instruction": "Add any number of position command data to the cyclic position command buffer of one axis. ",
        "input": "",
        "output": "AddCommand (int axis, CyclicBufferSingleAxisCommand *pCmd, int count)"
    },
    {
        "instruction": "Add one position command data each to the cyclic position command buffer of multiple axes. ",
        "input": "",
        "output": "AddCommand (AxisSelection *pAxisSelection, CyclicBufferMultiAxisCommands *pCmds)"
    },
    {
        "instruction": "Add any number of position command data to the cyclic position command buffer of multiple axes.",
        "input": "",
        "output": "AddCommand (AxisSelection *pAxisSelection, CyclicBufferMultiAxisCommands *pCmds, int count)"
    },
    {
        "instruction": "Start the execution of the cyclic position command buffer for a single axis.",
        "input": "",
        "output": "Execute (int axis, CyclicBufferSingleAxisOption *pOption=NULL)"
    },
    {
        "instruction": "Start the execution of the cyclic position command buffer for multiple axes. ",
        "input": "",
        "output": "Execute (AxisSelection *pAxisSelection, CyclicBufferMultiAxisOption *pOption=NULL)"
    },
    {
        "instruction": "Stop execution of the cyclic position command buffer of an axis and clear the buffer. ",
        "input": "",
        "output": "Abort (int axis)"
    },
    {
        "instruction": "Stop execution of the cyclic position command buffer of multiple axes and clear the buffer. ",
        "input": "",
        "output": "Abort (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop execution of the cyclic position command buffer of an axis and decelerate the axis to a stop using the quick stop deceleration.",
        "input": "",
        "output": "ExecQuickStop (int axis)"
    },
    {
        "instruction": "Stop execution of the cyclic position command buffer of multiple axes and decelerate the axes to a stop using the quick stop deceleration.",
        "input": "",
        "output": "ExecQuickStop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Get the cyclic position command buffer status of the specified axis.",
        "input": "",
        "output": "GetStatus (int axis, CyclicBufferSingleAxisStatus *pStatus)"
    },
    {
        "instruction": "Get the cyclic position command buffer status of the specified axes. ",
        "input": "",
        "output": "GetStatus (AxisSelection *pAxisSelection, CyclicBufferMultiAxisStatus *pStatus)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log. ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log. ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library. ",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the EventControl object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "EventControl (WMX3Api *f) "
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "EventControl (const EventControl &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "EventControl &  operator= (const EventControl &src) "
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "EventControl ()"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~EventControl ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "bool  IsDeviceValid () "
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Set an event.",
        "input": "",
        "output": "SetEvent (int *pId, EventInput *pEventInput, EventOutput *pEventOutput, EventOption *pOption=NULL)"
    },
    {
        "instruction": "Set an event.",
        "input": "",
        "output": "SetEvent (int *pId, EventInput *pEventInput, EventOutput *pEventOutput, int id, EventOption *pOption=NULL)"
    },
    {
        "instruction": "Get the input function module ID and output function module ID of an existing event.",
        "input": "",
        "output": "GetEventModuleId (int id, int *pInputModuleId, int *pOutputModuleId)"
    },
    {
        "instruction": "Get the parameters of an event. ",
        "input": "",
        "output": "GetEvent (int id, EventInput *pEventInput, EventOutput *pEventOutput, EventOption *pOption=NULL)"
    },
    {
        "instruction": "Get the option settings of an existing event. ",
        "input": "",
        "output": "GetEventOption (int id, EventOption *pOption)"
    },
    {
        "instruction": "This function sets the input function of an event.",
        "input": "",
        "output": "SetEventInput (int id, EventInput *pEventInput)"
    },
    {
        "instruction": "This function sets the output function of an event.",
        "input": "",
        "output": "SetEventOutput (int id, EventOutput *pEventOutput)"
    },
    {
        "instruction": "This function gets the input function of an event. ",
        "input": "",
        "output": "GetEventInput (int id, EventInput *pEventInput)"
    },
    {
        "instruction": "This function gets the output function of an event. ",
        "input": "",
        "output": "GetEventOutput (int id, EventOutput *pEventOutput)"
    },
    {
        "instruction": "Get the IDs of all existing events.",
        "input": "",
        "output": "GetAllEventID (AllEventID *pEventIdData, int filterInputModuleId=-1, int filterOutputModuleId=-1)"
    },
    {
        "instruction": "Enable or disable an existing event.",
        "input": "",
        "output": "EnableEvent (int id, unsigned char enable)"
    },
    {
        "instruction": "Remove an existing event.",
        "input": "",
        "output": "RemoveEvent (int id)"
    },
    {
        "instruction": "Clear all existing events.",
        "input": "",
        "output": "ClearAllEvent ()"
    },
    {
        "instruction": "Set parameters for a software touch probe channel. A software touch probe channel is able to latch onto the encoder data of an axis when a particular input signal is detected.",
        "input": "",
        "output": "SetSoftwareTouchProbe (unsigned int channel, unsigned char enable, int axis, int byteAddrs, int bitOffset, unsigned char logic, TouchProbeMode::T mode)"
    },
    {
        "instruction": "Enable a software touch probe channel. A software touch probe channel will only latch encoder data when enabled.",
        "input": "",
        "output": "EnableSoftwareTouchProbe (unsigned int channel, unsigned char enable)"
    },
    {
        "instruction": "Get parameters of a software touch probe channel.",
        "input": "",
        "output": "GetSoftwareTouchProbe (unsigned int channel, unsigned char *pEnabled, int *pAxis, int *pByteAddrs, int *pBitOffset, unsigned char *pLogic, TouchProbeMode::T *pMode)"
    },
    {
        "instruction": "Check whether a software touch probe channel has latched data. ",
        "input": "",
        "output": "IsSoftwareTouchProbeLatched (unsigned int channel, unsigned char *pLatched)"
    },
    {
        "instruction": "Get latched data of software touch probe.",
        "input": "",
        "output": "GetSoftwareTouchProbeCounterValue (unsigned int channel, unsigned char *pLatched, double *pCounterValue)"
    },
    {
        "instruction": "Set parameters for the hardware touch probe of an axis. A hardware touch probe latches the encoder data of the axis when the touch probe input signal is detected.",
        "input": "",
        "output": "SetHardwareTouchProbe (int axis, unsigned char enable, TouchProbeMode::T mode, TouchProbeSource::T triggerSource, unsigned int channel)"
    },
    {
        "instruction": "Get parameters and current state of the hardware touch probe of an axis. ",
        "input": "",
        "output": "GetHardwareTouchProbeStatus (int axis, HardwareTouchProbeStatus *pStatus)"
    },
    {
        "instruction": "Enable or disable the hardware touch probe of an axis.",
        "input": "",
        "output": "EnableHardwareTouchProbe (int axis, unsigned char enable)"
    },
    {
        "instruction": "Set parameters for a position synchronous output channel. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met. ",
        "input": "",
        "output": "SetPSOConfig (unsigned int channel, ComparisonType::T type, ComparatorSource *pSource, PSOOutput *pOutput, double minDurationMilliseconds, PSOOption *pOption=NULL)"
    },
    {
        "instruction": "Get parameters for a position synchronous output channel.",
        "input": "",
        "output": "GetPSOConfig (unsigned int channel, ComparisonType::T *pType, ComparatorSource *pSource, PSOOutput *pOutput, double *pMinDurationMilliseconds, PSOOption *pOption=NULL)"
    },
    {
        "instruction": "Set a single data point for a position synchronous output channel.",
        "input": "",
        "output": "SetPSOSingleData (unsigned int channel, double sData)"
    },
    {
        "instruction": "Set multiple data points for a position synchronous output channel.",
        "input": "",
        "output": "SetPSOMultipleData (unsigned int channel, int count, double *pMData)"
    },
    {
        "instruction": "Set data points over a range for a position synchronous output channel.",
        "input": "",
        "output": "SetPSOIntervalData (unsigned int channel, double rangeStart, double rangeEnd, double interval)"
    },
    {
        "instruction": "Get all data points that are currently set for a position synchronous output channel.",
        "input": "",
        "output": "GetPSOData (unsigned int channel, int *pCount, double *pMData, int maxCount)"
    },
    {
        "instruction": "Get the number of data points that are currently set for a position synchronous output channel. ",
        "input": "",
        "output": "GetPSODataCount (unsigned int channel, int *pCount)"
    },
    {
        "instruction": "Get the range and interval of a position synchronous output channel. ",
        "input": "",
        "output": "GetPSOIntervalData (unsigned int channel, double *pRangeStart, double *pRangeEnd, double *pInterval)"
    },
    {
        "instruction": "Start a position synchronous output channel. A position synchronous output channel must be started before it controls the output.",
        "input": "",
        "output": "StartPSO (unsigned int channel)"
    },
    {
        "instruction": "Stop a position synchronous output channel. A stopped position synchronous output channel will stop controlling any outputs. ",
        "input": "",
        "output": "StopPSO (unsigned int channel)"
    },
    {
        "instruction": "Get the state of a position synchronous output channel.",
        "input": "",
        "output": "GetPSOStatus (unsigned int channel, PSOStatus *pStatus)"
    },
    {
        "instruction": "Set parameters for a planned velocity override channel. A planned velocity override channel is able to override the velocity of an axis when certain conditions, such as an axis reaching a certain position, are met.",
        "input": "",
        "output": "SetPlannedVelOverrideConfig (unsigned int channel, ComparisonType::T type, ComparatorSource *pSource, int axis)"
    },
    {
        "instruction": "Get parameters for a planned velocity override channel.",
        "input": "",
        "output": "GetPlannedVelOverrideConfig (unsigned int channel, ComparisonType::T *pType, ComparatorSource *pSource, int *pAxis)"
    },
    {
        "instruction": "Set a single data point for a planned velocity override channel. ",
        "input": "",
        "output": "SetPlannedVelOverrideSingleData (unsigned int channel, PlannedVelocityData sData)"
    },
    {
        "instruction": "Set multiple data points for a planned velocity override channel.",
        "input": "",
        "output": "SetPlannedVelOverrideMultipleData (unsigned int channel, int count, PlannedVelocityData *pMData)"
    },
    {
        "instruction": "Get all data points that are currently set for a planned velocity override channel.",
        "input": "",
        "output": "GetPlannedVelOverrideData (unsigned int channel, int *pCount, PlannedVelocityData *pMData, int maxCount)"
    },
    {
        "instruction": "Get the number of data points that are currently set for a planned velocity override channel. ",
        "input": "",
        "output": "GetPlannedVelOverrideDataCount (unsigned int channel, int *pCount)"
    },
    {
        "instruction": "Start a planned velocity override channel. A planned velocity override channel must be started before it controls the output. ",
        "input": "",
        "output": "StartPlannedVelOverride (unsigned int channel)"
    },
    {
        "instruction": "Stop a planned velocity override channel. A stopped planned velocity override channel will stop controlling any outputs.",
        "input": "",
        "output": "StopPlannedVelOverride (unsigned int channel)"
    },
    {
        "instruction": "Get the state of a planned velocity override channel.",
        "input": "",
        "output": "GetPlannedVelOverrideStatus (unsigned int channel, PlannedVelocityStatus *pStatus)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the Io object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "Io (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class. ",
        "input": "",
        "output": "Io (const Io &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Io &  operator= (const Io &src) "
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "Io ()"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~Io ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Set the value of an output bit.",
        "input": "",
        "output": "SetOutBit (int addr, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of an output byte.",
        "input": "",
        "output": "SetOutByte (int addr, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple output bytes.",
        "input": "",
        "output": "SetOutBytes (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple output bits.",
        "input": "",
        "output": "SetOutBits (int *pAddr, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Set the value of output analog data spanning one byte.",
        "input": "",
        "output": "SetOutAnalogDataChar (int addr, char analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning one byte.",
        "input": "",
        "output": "SetOutAnalogDataUChar (int addr, unsigned char analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning two bytes.",
        "input": "",
        "output": "SetOutAnalogDataShort (int addr, short analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning two bytes.",
        "input": "",
        "output": "SetOutAnalogDataUShort (int addr, unsigned short analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning four bytes.",
        "input": "",
        "output": "SetOutAnalogDataInt (int addr, int analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning four bytes.",
        "input": "",
        "output": "SetOutAnalogDataUInt (int addr, unsigned int analogData)"
    },
    {
        "instruction": "Set the bitmask mode of output.",
        "input": "",
        "output": "SetOutBitMaskMode (bool enable)"
    },
    {
        "instruction": "Set the bitmask of output bit.",
        "input": "",
        "output": "SetOutBitMaskBit (int addr, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the bitmask of an output byte.",
        "input": "",
        "output": "SetOutBitMaskByte (int addr, unsigned char data)"
    },
    {
        "instruction": "Set the bitmask of multiple output bytes. ",
        "input": "",
        "output": "SetOutBitMaskBytes (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the bitmask of multiple output bits.",
        "input": "",
        "output": "SetOutBitMaskBits (int *pAddr, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Get the value of an input bit.",
        "input": "",
        "output": "GetInBit (int addr, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an input byte. ",
        "input": "",
        "output": "GetInByte (int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple input bytes.",
        "input": "",
        "output": "GetInBytes (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of input analog data spanning one byte.",
        "input": "",
        "output": "GetInAnalogDataChar (int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning one byte.",
        "input": "",
        "output": "GetInAnalogDataUChar (int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning two bytes.",
        "input": "",
        "output": "GetInAnalogDataShort (int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning two bytes.",
        "input": "",
        "output": "GetInAnalogDataUShort (int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning four bytes.",
        "input": "",
        "output": "GetInAnalogDataInt (int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning four bytes.",
        "input": "",
        "output": "GetInAnalogDataUInt (int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Get the value of an output bit.",
        "input": "",
        "output": "GetOutBit (int addr, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output byte.",
        "input": "",
        "output": "GetOutByte (int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple output bytes. ",
        "input": "",
        "output": "GetOutBytes (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of output analog data spanning one byte.",
        "input": "",
        "output": "GetOutAnalogDataChar (int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning one byte.",
        "input": "",
        "output": "GetOutAnalogDataUChar (int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning two bytes.",
        "input": "",
        "output": "GetOutAnalogDataShort (int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning two bytes.",
        "input": "",
        "output": "GetOutAnalogDataUShort (int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning four bytes.",
        "input": "",
        "output": "GetOutAnalogDataInt (int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning four bytes.",
        "input": "",
        "output": "GetOutAnalogDataUInt (int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Get the bitmask mode of output.",
        "input": "",
        "output": "GetOutBitMaskMode (bool *pEnable)"
    },
    {
        "instruction": "Get the bitmask of an output bit.",
        "input": "",
        "output": "GetOutBitMaskBit (int addr, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the bitmask of an output byte.",
        "input": "",
        "output": "GetOutBitMaskByte (int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the bitmask of multiple output bytes. ",
        "input": "",
        "output": "GetOutBitMaskBytes (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of an output bit.",
        "input": "",
        "output": "SetOutBitEx (int addr, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of an output byte. ",
        "input": "",
        "output": "SetOutByteEx (int addr, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple output bytes.",
        "input": "",
        "output": "SetOutBytesEx (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple output bits. ",
        "input": "",
        "output": "SetOutBitsEx (int *pAddr, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Set the value of output analog data spanning one byte.",
        "input": "",
        "output": "SetOutAnalogDataCharEx (int addr, char analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning one byte. ",
        "input": "",
        "output": "SetOutAnalogDataUCharEx (int addr, unsigned char analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning two bytes. ",
        "input": "",
        "output": "SetOutAnalogDataShortEx (int addr, short analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning two bytes.",
        "input": "",
        "output": "SetOutAnalogDataUShortEx (int addr, unsigned short analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning four bytes. ",
        "input": "",
        "output": "SetOutAnalogDataIntEx (int addr, int analogData)"
    },
    {
        "instruction": "Set the value of output analog data spanning four bytes.",
        "input": "",
        "output": "SetOutAnalogDataUIntEx (int addr, unsigned int analogData)"
    },
    {
        "instruction": "Get the value of an input bit. ",
        "input": "",
        "output": "GetInBitEx (int addr, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an input byte.",
        "input": "",
        "output": "GetInByteEx (int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple input bytes.",
        "input": "",
        "output": "GetInBytesEx (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of input analog data spanning one byte.",
        "input": "",
        "output": "GetInAnalogDataCharEx (int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning one byte.",
        "input": "",
        "output": "GetInAnalogDataUCharEx (int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning two bytes",
        "input": "",
        "output": "GetInAnalogDataShortEx (int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning two bytes.",
        "input": "",
        "output": "GetInAnalogDataUShortEx (int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning four bytes.",
        "input": "",
        "output": "GetInAnalogDataIntEx (int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of input analog data spanning four bytes.",
        "input": "",
        "output": "GetInAnalogDataUIntEx (int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Get the value of an output bit.",
        "input": "",
        "output": "GetOutBitEx (int addr, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output byte.",
        "input": "",
        "output": "GetOutByteEx (int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple output bytes.",
        "input": "",
        "output": "GetOutBytesEx (int addr, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of output analog data spanning one byte. ",
        "input": "",
        "output": "GetOutAnalogDataCharEx (int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning one byte.",
        "input": "",
        "output": "GetOutAnalogDataUCharEx (int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning two bytes. ",
        "input": "",
        "output": "GetOutAnalogDataShortEx (int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning two bytes. ",
        "input": "",
        "output": "GetOutAnalogDataUShortEx (int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning four bytes.",
        "input": "",
        "output": "GetOutAnalogDataIntEx (int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of output analog data spanning four bytes. ",
        "input": "",
        "output": "GetOutAnalogDataUIntEx (int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Set the initial value of an output byte that is applied when communication is started.",
        "input": "",
        "output": "SetInitialOutByte (int addr, unsigned char data, unsigned char enable)"
    },
    {
        "instruction": "Set the initial values of multiple output bytes that are applied when communication is started. ",
        "input": "",
        "output": "SetInitialOutBytes (int addr, int size, unsigned char *pData, unsigned char *pEnable)"
    },
    {
        "instruction": "Set the initial values of multiple output bytes that are applied when communication is started. ",
        "input": "",
        "output": "GetInitialOutByte (int addr, unsigned char *pData, unsigned char *pEnable)"
    },
    {
        "instruction": "Get the initial values of multiple output bytes that are applied when communication is started. ",
        "input": "",
        "output": "GetInitialOutBytes (int addr, int size, unsigned char *pData, unsigned char *pEnable)"
    },
    {
        "instruction": " Get the ID of the interrupt (cyclic handler) that will set the initial value of the specified output byte. ",
        "input": "",
        "output": "GetInitialOutByteInterruptId (int addr, unsigned char *pInterruptId)"
    },
    {
        "instruction": "Get the IDs of the interrupts (cyclic handlers) that will set the initial values of the specified output bytes.",
        "input": "",
        "output": "GetInitialOutBytesInterruptId (int addr, int size, unsigned char *pInterruptId)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the Log object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "Log (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Log (const Log &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Log & operator= (const Log &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "Log ()"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~Log ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Start logging data. ",
        "input": "",
        "output": "StartLog (unsigned int channel)"
    },
    {
        "instruction": "Stop logging data.",
        "input": "",
        "output": "StopLog (unsigned int channel)"
    },
    {
        "instruction": "Reset the log settings, options, and statuses for the specified log channel.",
        "input": "",
        "output": "ResetLog (unsigned int channel)"
    },
    {
        "instruction": "Set the log header string that is copied to the beginning of the log file.",
        "input": "",
        "output": "SetLogHeader (unsigned int channel, char **ppLine, unsigned int numLines)"
    },
    {
        "instruction": "Specify data to be collected by the logging operation.",
        "input": "",
        "output": "SetLog (unsigned int channel, LogInput *input)"
    },
    {
        "instruction": "Set the log options for a log channel.",
        "input": "",
        "output": "SetLogOption (unsigned int channel, LogChannelOptions *pOption)"
    },
    {
        "instruction": "Get the log options for a log channel. ",
        "input": "",
        "output": "GetLogOption (unsigned int channel, LogChannelOptions *pOption)"
    },
    {
        "instruction": "Set the file path for a log channel.",
        "input": "",
        "output": "SetLogFilePath (unsigned int channel, LogFilePathA *pPath)"
    },
    {
        "instruction": "Get the file path for a log channel.",
        "input": "",
        "output": "GetLogFilePath (unsigned int channel, LogFilePathA *pPath)"
    },
    {
        "instruction": "Set the file path for a log channel.",
        "input": "",
        "output": "SetLogFilePath (unsigned int channel, LogFilePathW *pPath)"
    },
    {
        "instruction": "Get the file path for a log channel.",
        "input": "",
        "output": "GetLogFilePath (unsigned int channel, LogFilePathW *pPath)"
    },
    {
        "instruction": "Get the current status of the data logging operation.",
        "input": "",
        "output": "GetLogStatus (unsigned int channel, LogStatus *pStatus)"
    },
    {
        "instruction": "Get the current status of the data logging operation. Compared to GetLogStatus, more detailed statuses can be obtained. ",
        "input": "",
        "output": "GetDetailLogStatus (unsigned int channel, DetailLogStatus *pStatus)"
    },
    {
        "instruction": "Open the memory log buffer.",
        "input": "",
        "output": "OpenMemoryLogBuffer (unsigned int channel)"
    },
    {
        "instruction": "Close the memory log buffer.",
        "input": "",
        "output": "CloseMemoryLogBuffer (unsigned int channel)"
    },
    {
        "instruction": "Specify data to be collected by the memory log operation.",
        "input": "",
        "output": "SetMemoryLog (unsigned int channel, LogInput *input)"
    },
    {
        "instruction": "Set the memory log options for a memory log channel.",
        "input": "",
        "output": "SetMemoryLogOption (unsigned int channel, MemoryLogOptions *pOption)"
    },
    {
        "instruction": "Get the memory log options for a memory log channel.",
        "input": "",
        "output": "GetMemoryLogOption (unsigned int channel, MemoryLogOptions *pOption)"
    },
    {
        "instruction": "Start the memory log operation.",
        "input": "",
        "output": "StartMemoryLog (unsigned int channel)"
    },
    {
        "instruction": "Stop the memory log operation. ",
        "input": "",
        "output": "StopMemoryLog (unsigned int channel)"
    },
    {
        "instruction": "Reset the memory log settings, options, and statuses for the specified memory log channel. ",
        "input": "",
        "output": "ResetMemoryLog (unsigned int channel)"
    },
    {
        "instruction": "Get the current status of the memory log operation.",
        "input": "",
        "output": "GetMemoryLogStatus (unsigned int channel, MemoryLogStatus *pStatus)"
    },
    {
        "instruction": "Retrieve data from memory log of a single module.",
        "input": "",
        "output": "GetMemoryLogData (unsigned int channel, LogOutput *pOutput)"
    },
    {
        "instruction": "Retrieve data from memory log of multiple modules.",
        "input": "",
        "output": "GetMemoryLogData (unsigned int channel, LogOutput **ppOutput, unsigned int size)"
    },
    {
        "instruction": "Set the parameters for the API log. ",
        "input": "",
        "output": "SetApiLog (char *pPath, ApiLogOptions *pOptions=NULL, unsigned int buffSize=16777216)"
    },
    {
        "instruction": "Set the parameters for the API log",
        "input": "",
        "output": "SetApiLog (wchar_t *pPath, ApiLogOptions *pOptions=NULL, unsigned int buffSize=16777216)"
    },
    {
        "instruction": "Start logging data to the API log. ",
        "input": "",
        "output": "StartApiLog ()"
    },
    {
        "instruction": "Stop logging data to the API log.",
        "input": "",
        "output": "StopApiLog ()"
    },
    {
        "instruction": "Get the current status of the API log.",
        "input": "",
        "output": "GetApiLogStatus (ApiLogStatus *pStatus)"
    },
    {
        "instruction": "Open an API log file to extract information from the contents.",
        "input": "",
        "output": "OpenApiLogFile (char *pPath, FILE **ppFile)"
    },
    {
        "instruction": "Open an API log file to extract information from the contents.",
        "input": "",
        "output": "OpenApiLogFile (wchar_t *pPath, FILE **ppFile)"
    },
    {
        "instruction": "Extract the information of one API function call from the API log file.",
        "input": "",
        "output": "GetApiLogData (FILE *pFile, unsigned char *pDataBuff, unsigned int buffSize, ApiLogInfo *pApiLogInfo=NULL)"
    },
    {
        "instruction": "Close an API log file.",
        "input": "",
        "output": "CloseApiLogFile (FILE *pFile)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of a timestamp. ",
        "input": "",
        "output": "TimestampToString (long long timestamp, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of a timestamp.",
        "input": "",
        "output": "TimestampToString (long long timestamp, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "Compensation (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Compensation (const Compensation &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Compensation & operator= (const Compensation &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "Compensation ()"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~Compensation ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Set pitch error compensation parameters. ",
        "input": "",
        "output": "SetPitchErrorCompensation (int axis, PitchErrorCompensationData *pitchErrCompData)"
    },
    {
        "instruction": "Set free position mode pitch error compensation parameters.",
        "input": "",
        "output": "SetPitchErrorCompensation (int axis, PitchErrorCompensationFreePositionData *pitchErrCompData)"
    },
    {
        "instruction": "Get pitch error compensation parameters. ",
        "input": "",
        "output": "GetPitchErrorCompensation (int axis, PitchErrorCompensationData *pitchErrCompData)"
    },
    {
        "instruction": "Get free position mode pitch error compensation parameters.",
        "input": "",
        "output": "GetPitchErrorCompensation (int axis, PitchErrorCompensationFreePositionData *pitchErrCompData)"
    },
    {
        "instruction": "Enable pitch error compensation.",
        "input": "",
        "output": "EnablePitchErrorCompensation (int axis)"
    },
    {
        "instruction": "Disable pitch error compensation.",
        "input": "",
        "output": "DisablePitchErrorCompensation (int axis)"
    },
    {
        "instruction": "Obtain the pitch error compensation amount at the specified position.",
        "input": "",
        "output": "GetPitchErrorCompensationAtPosition (int axis, double pos, double *pCompensation)"
    },
    {
        "instruction": "Set two-dimensional (2D) pitch error compensation parameters.",
        "input": "",
        "output": "Set2DPitchErrorCompensation (unsigned int channel, TwoDPitchErrorCompensationData *pitchErrCompData2D)"
    },
    {
        "instruction": "Set free position two-dimensional (2D) pitch error compensation parameters. ",
        "input": "",
        "output": "Set2DPitchErrorCompensation (unsigned int channel, TwoDPitchErrorCompensationFreePositionData *pitchErrCompData2D)"
    },
    {
        "instruction": "Get two-dimensional (2D) pitch error compensation parameters.",
        "input": "",
        "output": "Get2DPitchErrorCompensation (unsigned int channel, TwoDPitchErrorCompensationData *pitchErrCompData2D)"
    },
    {
        "instruction": "Get free position two-dimensional (2D) pitch error compensation parameters. ",
        "input": "",
        "output": "Get2DPitchErrorCompensation (unsigned int channel, TwoDPitchErrorCompensationFreePositionData *pitchErrCompData2D)"
    },
    {
        "instruction": "Enable two-dimensional (2D) pitch error compensation.",
        "input": "",
        "output": "Enable2DPitchErrorCompensation (unsigned int channel)"
    },
    {
        "instruction": "Disable two-dimensional (2D) pitch error compensation.",
        "input": "",
        "output": "Disable2DPitchErrorCompensation (unsigned int channel)"
    },
    {
        "instruction": "Obtain the two-dimensional (2D) pitch error compensation amount at the specified position.",
        "input": "",
        "output": "Get2DPitchErrorCompensationAtPosition (unsigned int channel, double refPos1, double refPos2, double *pCompensation)"
    },
    {
        "instruction": "Set backlash compensation parameters. ",
        "input": "",
        "output": "SetBacklashCompensation (int axis, BacklashCompensationData *pBacklashCompData)"
    },
    {
        "instruction": "Get backlash compensation parameters.",
        "input": "",
        "output": "GetBacklashCompensation (int axis, BacklashCompensationData *pBacklashCompData)"
    },
    {
        "instruction": "Enable backlash compensation.",
        "input": "",
        "output": "EnableBacklashCompensation (int axis)"
    },
    {
        "instruction": "Disable backlash compensation.",
        "input": "",
        "output": "DisableBacklashCompensation (int axis)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.  ",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library. ",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "AdvancedMotion (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class. ",
        "input": "",
        "output": "AdvancedMotion (const AdvancedMotion &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "AdvancedMotion & operator= (const AdvancedMotion &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "AdvancedMotion ()"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~AdvancedMotion ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library. ",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "This class contains data for a coordinated position command with two or more axes. ",
        "input": "",
        "output": "CoordinatedJerkRatioPosCommand"
    },
    {
        "instruction": "This class contains data for a coordinated position command.",
        "input": "",
        "output": "CoordinatedPosCommand"
    },
    {
        "instruction": "This class contains data for additional interpolation segment data for 3D path interpolation.",
        "input": "",
        "output": "PathIntpl3DAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a 3D path interpolation motion command.",
        "input": "",
        "output": "PathIntpl3DCommand"
    },
    {
        "instruction": "This class contains data for additional interpolation segment data for path interpolation.",
        "input": "",
        "output": "PathIntplAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a path interpolation motion command.",
        "input": "",
        "output": "PathIntplCommand"
    },
    {
        "instruction": "This enumerator class enumerates the coordinate types of path interpolations. The coordinate type determines how the coordinates are specified when defining positions in a path interpolation.",
        "input": "",
        "output": "PathIntplCoordinateType"
    },
    {
        "instruction": "This class contains data for path interpolation with look ahead.",
        "input": "",
        "output": "PathIntplLookaheadCommand"
    },
    {
        "instruction": "This class contains data for one point in the path interpolation with look ahead motion command.",
        "input": "",
        "output": "PathIntplLookaheadCommandPoint"
    },
    {
        "instruction": "This class contains the configuration data for a path interpolation with look ahead channel.",
        "input": "",
        "output": "PathIntplLookaheadConfiguration"
    },
    {
        "instruction": "This enumerator class enumerates the coordinate types of path interpolations with look ahead. The coordinate type determines how the coordinates are specified when defining positions in a path interpolation with look ahead.",
        "input": "",
        "output": "PathIntplLookaheadCoordinateType"
    },
    {
        "instruction": "This enumerator class enumerates the segment types of motion segments in a path interpolation with look ahead.",
        "input": "",
        "output": "PathIntplLookaheadSegmentType"
    },
    {
        "instruction": "This enumerator class enumerates the states of a path interpolation with look ahead channel.",
        "input": "",
        "output": "PathIntplLookaheadState"
    },
    {
        "instruction": "This class contains status data for a path interpolation with look ahead channel. ",
        "input": "",
        "output": "PathIntplLookaheadStatus"
    },
    {
        "instruction": "This enumerator class enumerates the output sources of outputs in a path interpolation.",
        "input": "",
        "output": "PathIntplOutputSource"
    },
    {
        "instruction": "This enumerator class enumerates the output types of outputs in a path interpolation.",
        "input": "",
        "output": "PathIntplOutputType"
    },
    {
        "instruction": "This enumerator class enumerates the segment types of motion segments in a path interpolation.",
        "input": "",
        "output": "PathIntplSegmentType"
    },
    {
        "instruction": "This class contains data for a path interpolation with rotation command. ",
        "input": "",
        "output": "PathIntplWithRotationCommand"
    },
    {
        "instruction": "This class contains data for one point in the path interpolation with rotation motion command.",
        "input": "",
        "output": "PathIntplWithRotationCommandPoint"
    },
    {
        "instruction": "This class contains the configuration data for a path interpolation with rotation channel.",
        "input": "",
        "output": "PathIntplWithRotationConfiguration"
    },
    {
        "instruction": "This enumerator class enumerates the path interpolation with rotation states. ",
        "input": "",
        "output": "PathIntplWithRotationState"
    },
    {
        "instruction": "This class contains status data for a path interpolation with rotation channel.",
        "input": "",
        "output": "PathIntplWithRotationStatus"
    },
    {
        "instruction": "This class contains data for a spline command in which the time at each point is specified.",
        "input": "",
        "output": "PointTimeSplineCommand"
    },
    {
        "instruction": "This class contains data for a position command.",
        "input": "",
        "output": "PosCommand"
    },
    {
        "instruction": "This class contains data for a spline command in which the spline is traversed using a motion profile.",
        "input": "",
        "output": "ProfileSplineCommand"
    },
    {
        "instruction": "This class contains data for simulating a 3D path interpolation motion.",
        "input": "",
        "output": "SimulatePathIntpl3DCommand"
    },
    {
        "instruction": "This class contains data for simulating a path interpolation motion command. ",
        "input": "",
        "output": "SimulatePathIntplCommand"
    },
    {
        "instruction": "This class contains data for a spline point. ",
        "input": "",
        "output": "This class contains data for simulating a path interpolation motion command. "
    },
    {
        "instruction": "This class contains data for a spline command in which the total time is specified.",
        "input": "",
        "output": "TotalTimeSplineCommand"
    },
    {
        "instruction": "This class contains data for a two link motion command for a linear axis.",
        "input": "",
        "output": "TwoLinkLinearCommand"
    },
    {
        "instruction": "This class contains data for a two link motion command for a rotary axis.",
        "input": "",
        "output": "TwoLinkRotaryCommand"
    },
    {
        "instruction": "This class contains data for a spline command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. ",
        "input": "",
        "output": "VelAccLimitedSplineCommand"
    },
    {
        "instruction": "Allocate buffer memory for a spline execution channel.",
        "input": "",
        "output": "CreateSplineBuffer (int channel, unsigned int points)"
    },
    {
        "instruction": "Free buffer memory for a spline execution channel.",
        "input": "",
        "output": "FreeSplineBuffer (int channel)"
    },
    {
        "instruction": "Get the amount of buffer memory currently allocated to a spline execution channel. ",
        "input": "",
        "output": "GetSplineBufferPoints (int channel, unsigned int *pPoints)"
    },
    {
        "instruction": "Get the number of bytes required per point data in the spline execution buffer memory.",
        "input": "",
        "output": "GetSplineBytesPerPoint (unsigned int *pBytes)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions. ",
        "input": "",
        "output": "StartCSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the spline is traversed using a motion profile. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic spline motion command with multiple trigger events in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions. ",
        "input": "",
        "output": "StartCBSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": " StartCBSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint) "
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint) "
    },
    {
        "instruction": "Start a cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions. ",
        "input": "",
        "output": "StartCBSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the time at each point is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the spline is traversed using a motion profile. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "input": "",
        "output": "StartCBSplinePos (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the time at each point is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, PointTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, double *pPointTimeMilliseconds, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, TotalTimeSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, ProfileSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered cubic basis spline motion command with multiple trigger events in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "input": "",
        "output": "StartCBSplineMov (int channel, VelAccLimitedSplineCommand *pSplineCommand, unsigned int numPoints, SplinePoint *pPoint, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Allocate buffer memory to an axis for the execution of path interpolation commands. ",
        "input": "",
        "output": "CreatePathIntplBuffer (int axis, unsigned int points)"
    },
    {
        "instruction": "Free path interpolation buffer memory for an axis.",
        "input": "",
        "output": "FreePathIntplBuffer (int axis)"
    },
    {
        "instruction": "Get the amount of path interpolation buffer memory currently allocated to an axis. ",
        "input": "",
        "output": "GetPathIntplBufferPoints (int axis, unsigned int *pPoints)"
    },
    {
        "instruction": "Get the number of bytes required per point data in the path interpolation buffer memory.",
        "input": "",
        "output": "GetPathIntplBytesPerPoint (unsigned int *pBytes)"
    },
    {
        "instruction": "Start an absolute position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplPos (PathIntplCommand *pPathIntplCommand, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplMov (PathIntplCommand *pPathIntplCommand, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start an absolute position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplPos (PathIntplCommand *pPathIntplCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplMov (PathIntplCommand *pPathIntplCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start an absolute position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplPos (PathIntplCommand *pPathIntplCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntplMov (PathIntplCommand *pPathIntplCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PathIntplAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Override a path interpolation motion using a velocity multiplier.",
        "input": "",
        "output": "OverridePathIntplVelocityMultiplier (int axis, double multiplier)"
    },
    {
        "instruction": "Start an absolute position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DPos (PathIntpl3DCommand *pPathIntplCommand, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DMov (PathIntpl3DCommand *pPathIntplCommand, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start an absolute position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DPos (PathIntpl3DCommand *pPathIntplCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DMov (PathIntpl3DCommand *pPathIntplCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start an absolute position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DPos (PathIntpl3DCommand *pPathIntplCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Start a relative position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "input": "",
        "output": "StartPathIntpl3DMov (PathIntpl3DCommand *pPathIntplCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PathIntpl3DAdditionalCommand *pPathIntplAddlCommand=NULL)"
    },
    {
        "instruction": "Override a 3D path interpolation motion using a velocity multiplier.",
        "input": "",
        "output": "OverridePathIntpl3DVelocityMultiplier (int axis, double multiplier)"
    },
    {
        "instruction": "Allocate buffer memory for a path interpolation with rotation channel.",
        "input": "",
        "output": "CreatePathIntplWithRotationBuffer (int channel, unsigned int points)"
    },
    {
        "instruction": "Free buffer memory for a path interpolation with rotation channel.",
        "input": "",
        "output": "FreePathIntplWithRotationBuffer (int channel)"
    },
    {
        "instruction": "Get the number of bytes required per point data in the path interpolation with rotation buffer memory.",
        "input": "",
        "output": "GetPathIntplWithRotationBytesPerPoint (unsigned int *pBytes)"
    },
    {
        "instruction": "Set the configuration data for a path interpolation with rotation channel.",
        "input": "",
        "output": "SetPathIntplWithRotationConfiguration (int channel, PathIntplWithRotationConfiguration *pConfig)"
    },
    {
        "instruction": "Add interpolation commands to a path interpolation with rotation channel.",
        "input": "",
        "output": "AddPathIntplWithRotationCommand (int channel, PathIntplWithRotationCommand *pCommand)"
    },
    {
        "instruction": "Execute motion for a path interpolation with rotation channel.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel)"
    },
    {
        "instruction": "Execute triggered motion for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, Trigger *pTrigger)"
    },
    {
        "instruction": "Execute triggered motion for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied. ",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Execute motion to the specified position for a path interpolation with rotation channel.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, double pos)"
    },
    {
        "instruction": "Execute triggered motion to the specified position for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, double pos, Trigger *pTrigger)"
    },
    {
        "instruction": "Execute triggered motion to the specified position for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, double pos, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Execute motion to the specified point for a path interpolation with rotation channel. ",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, unsigned int point)"
    },
    {
        "instruction": "Execute triggered motion to the specified point for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, unsigned int point, Trigger *pTrigger)"
    },
    {
        "instruction": "Execute triggered motion to the specified point for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPathIntplWithRotation (int channel, unsigned int point, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Clear all data for a path interpolation with rotation channel.",
        "input": "",
        "output": "ClearPathIntplWithRotation (int channel)"
    },
    {
        "instruction": "Get the current status for a path inteprolation with rotation channel.",
        "input": "",
        "output": "GetPathIntplWithRotationStatus (int channel, PathIntplWithRotationStatus *pStatus)"
    },
    {
        "instruction": "Allocate buffer memory for a path interpolation with look ahead channel. ",
        "input": "",
        "output": "CreatePathIntplLookaheadBuffer (int channel, unsigned int points)"
    },
    {
        "instruction": "Free buffer memory for a path interpolation with lookahead channel. ",
        "input": "",
        "output": "FreePathIntplLookaheadBuffer (int channel)"
    },
    {
        "instruction": "Get the number of bytes required per point data in the path interpolation with look ahead buffer memory.",
        "input": "",
        "output": "GetPathIntplLookaheadBytesPerPoint (unsigned int *pBytes)"
    },
    {
        "instruction": "Set the configuration data for a path interpolation with lookahead channel. ",
        "input": "",
        "output": "SetPathIntplLookaheadConfiguration (int channel, PathIntplLookaheadConfiguration *pConfig)"
    },
    {
        "instruction": "Add interpolation commands to a path interpolation with look ahead channel. ",
        "input": "",
        "output": "AddPathIntplLookaheadCommand (int channel, PathIntplLookaheadCommand *pCommand)"
    },
    {
        "instruction": "Add multiple interpolation commands to a path interpolation with look ahead channel.",
        "input": "",
        "output": "AddPathIntplLookaheadCommand (int channel, unsigned int numCommands, PathIntplLookaheadCommand *pCommand)"
    },
    {
        "instruction": "Start the motion for a path interpolation with look ahead channel.",
        "input": "",
        "output": "StartPathIntplLookahead (int channel)"
    },
    {
        "instruction": "Stop the motion for a path interpolation with look ahead channel.",
        "input": "",
        "output": "StopPathIntplLookahead (int channel)"
    },
    {
        "instruction": "Clear all data for a path interpolation with look ahead channel.",
        "input": "",
        "output": "ClearPathIntplLookahead (int channel)"
    },
    {
        "instruction": "Get the current status for a path interpolation with look ahead channel. ",
        "input": "",
        "output": "GetPathIntplLookaheadStatus (int channel, PathIntplLookaheadStatus *pStatus)"
    },
    {
        "instruction": "Start an interpolation between two axes, where one axis executes a normal position command and the second axis travels a specified distance in the same amount of time.",
        "input": "",
        "output": "StartCoordinatedPos (CoordinatedPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start multiple interpolations, each between pairs of two axes, where one axis executes a normal position command and the second axis travels a specified distance in the same amount of time. ",
        "input": "",
        "output": "StartCoordinatedPos (unsigned int numCommands, CoordinatedPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start an interpolation between two or more axes, where one axis executes a normal position command and the remaining axes travel the specified distances in the same amount of time.",
        "input": "",
        "output": "StartCoordinatedPos (CoordinatedJerkRatioPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in absolute coordinates.",
        "input": "",
        "output": "StartTwoLinkLinearPos (TwoLinkLinearCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in relative coordinates.",
        "input": "",
        "output": "StartTwoLinkLinearMov (TwoLinkLinearCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in absolute coordinates.",
        "input": "",
        "output": "StartTwoLinkRotaryPos (TwoLinkRotaryCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in relative coordinates.",
        "input": "",
        "output": "StartTwoLinkRotaryMov (TwoLinkRotaryCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in absolute coordinates.",
        "input": "",
        "output": "StartTwoLinkUntetheredLinearPos (TwoLinkLinearCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in relative coordinates.",
        "input": "",
        "output": "StartTwoLinkUntetheredLinearMov (TwoLinkLinearCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in absolute coordinates.",
        "input": "",
        "output": "StartTwoLinkUntetheredRotaryPos (TwoLinkRotaryCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in relative coordinates.",
        "input": "",
        "output": "StartTwoLinkUntetheredRotaryMov (TwoLinkRotaryCommand *pTwoLinkCommand)"
    },
    {
        "instruction": "Simulate a path interpolation command without moving any axes. The move distance, remain distance, and total distance after the path interpolation runs for a specified amount of time are returned.",
        "input": "",
        "output": "SimulatePosAtTime (SimulatePathIntplCommand *pPathIntplCommand, double timeMilliseconds, double *pPos1, double *pPos2, double *pMoveDistance, double *pRemainDistance, double *pTotalDistance)"
    },
    {
        "instruction": "Simulate a path interpolation command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned.",
        "input": "",
        "output": "SimulateTimeAtPos (SimulatePathIntplCommand *pPathIntplCommand, double specificPos1, double specificPos2, unsigned int minimumSearchIndex, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds, double *pTotalTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a path interpolation command without moving any axes. The move time, remain time, and total time after the path interpolation runs for the specified distance are returned.",
        "input": "",
        "output": "SimulateTimeAtDist (SimulatePathIntplCommand *pPathIntplCommand, double specificDistance, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds, double *pTotalTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a 3D path interpolation command without moving any axes. The move distance, remain distance, and total distance after the 3D path interpolation runs for a specified amount of time are returned.",
        "input": "",
        "output": "SimulatePosAtTime (SimulatePathIntpl3DCommand *pPathIntplCommand, double timeMilliseconds, double *pPos1, double *pPos2, double *pPos3, double *pMoveDistance, double *pRemainDistance, double *pTotalDistance)"
    },
    {
        "instruction": "Simulate a 3D path interpolation command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned",
        "input": "",
        "output": "SimulateTimeAtPos (SimulatePathIntpl3DCommand *pPathIntplCommand, double specificPos1, double specificPos2, double specificPos3, unsigned int minimumSearchIndex, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds, double *pTotalTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a 3D path interpolation command without moving any axes. The move time, remain time, and total time after the 3D path interpolation runs for the specified distance are returned.",
        "input": "",
        "output": "SimulateTimeAtDist (SimulatePathIntpl3DCommand *pPathIntplCommand, double specificDistance, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds, double *pTotalTimeMilliseconds)"
    },
    {
        "instruction": "This class contains options for dancer control.",
        "input": "",
        "output": "DancerControlOptions"
    },
    {
        "instruction": "This class contains the status for dancer control.",
        "input": "",
        "output": "DancerControlStatus"
    },
    {
        "instruction": "This class contains E-CAM clutch options. The E-CAM clutch determines how the slave axis synchronizes with the master axis when E-CAM is started.",
        "input": "",
        "output": "ECAMClutchOptions"
    },
    {
        "instruction": "This enumerator class enumerates the E-CAM clutch types.",
        "input": "",
        "output": "ECAMClutchType"
    },
    {
        "instruction": "This class contains all settings for E-CAM control, including E-CAM table data. ",
        "input": "",
        "output": "ECAMData"
    },
    {
        "instruction": "This class contains E-CAM options, including the E-CAM clutch options. ",
        "input": "",
        "output": "ECAMOptions"
    },
    {
        "instruction": "This class contains E-CAM source options. This determines the source of the master input that is used to calculate the slave command position from the E-CAM table.",
        "input": "",
        "output": "ECAMSourceOptions"
    },
    {
        "instruction": "This enumerator class enumerates the sources of the E-CAM master input. ",
        "input": "",
        "output": "ECAMSourceType"
    },
    {
        "instruction": "This enumerator class enumerates the types of E-CAM, which determine certain characteristics of E-CAM.",
        "input": "",
        "output": "ECAMType"
    },
    {
        "instruction": "Start E-CAM control.",
        "input": "",
        "output": "StartECAM (int channel, ECAMData *pECAMData)"
    },
    {
        "instruction": "Get E-CAM control parameters.",
        "input": "",
        "output": "GetECAM (int channel, ECAMData *pECAMData)"
    },
    {
        "instruction": "Stop E-CAM control.",
        "input": "",
        "output": "StopECAM (int channel)"
    },
    {
        "instruction": "Start dancer control.",
        "input": "",
        "output": "StartDancerControl (int axis, DancerControlOptions *pDancerControlOptions)"
    },
    {
        "instruction": "Stop dancer control.",
        "input": "",
        "output": "StopDancerControl (int axis)"
    },
    {
        "instruction": "Get the dancer control status.",
        "input": "",
        "output": "GetDancerControlStatus (int axis, DancerControlStatus *pDancerControlStatus)"
    },
    {
        "instruction": "Start constant linear velocity control for an axis.",
        "input": "",
        "output": "SetConstantLinearVel (int masterAxis, int slaveAxis, double centerPos, double minR, double positiveMaxR, double negativeMaxR, double constLinVel, double initVelVariance)"
    },
    {
        "instruction": "Resolve constant linear velocity control for an axis.",
        "input": "",
        "output": "ResolveConstantLinearVel (int axis)"
    },
    {
        "instruction": "Default constructor for this class.",
        "input": "",
        "output": "WMX3Api ()"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~WMX3Api ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Start the WMX3 engine without creating a device. ",
        "input": "",
        "output": "StartEngine (const char *path, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Start the WMX3 engine without creating a device. ",
        "input": "",
        "output": "StartEngine (const wchar_t *path, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Stop the currently running WMX3 engine and then restart the WMX3 engine. ",
        "input": "",
        "output": "RestartEngine (const char *path, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Stop the currently running WMX3 engine and then restart the WMX3 engine. ",
        "input": "",
        "output": "RestartEngine (const wchar_t *path, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Stop the currently running WMX3 engine.",
        "input": "",
        "output": "StopEngine (unsigned int waitTimeMilliseconds=0)"
    },
    {
        "instruction": "Create a device to interface with the WMX3 engine. ",
        "input": "",
        "output": "CreateDevice (const char *path, DeviceType::T type=DeviceType::T::DeviceTypeNormal, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Create a device to interface with the WMX3 engine. ",
        "input": "",
        "output": "CreateDevice (const wchar_t *path, DeviceType::T type=DeviceType::T::DeviceTypeNormal, unsigned int waitTimeMilliseconds=0, int core=-1, DWORD_PTR affinityMask=0)"
    },
    {
        "instruction": "Close a device.",
        "input": "",
        "output": "CloseDevice (bool exitNoDev=true)"
    },
    {
        "instruction": "Get the device ID number of the device.",
        "input": "",
        "output": "GetDeviceID (int *id)"
    },
    {
        "instruction": "Configure the engine to automatically quit or not automatically quit when the last device is closed by a watchdog time out.",
        "input": "",
        "output": "AutoQuitWithoutActiveDev (bool quit)"
    },
    {
        "instruction": "Set the watchdog time out period for the device that called this function.",
        "input": "",
        "output": "SetWatchdog (unsigned int watchdog)"
    },
    {
        "instruction": "Set the watchdog time out period for a specific device. ",
        "input": "",
        "output": "SetWatchdog (int deviceId, unsigned int watchdog)"
    },
    {
        "instruction": "Get the watchdog time out period and the current watchdog count.",
        "input": "",
        "output": "GetWatchdog (unsigned int *watchdog, unsigned int *watchdogCount=NULL)"
    },
    {
        "instruction": "Reset the watchdog count of a device.",
        "input": "",
        "output": "ResetWatchdogTimer ()"
    },
    {
        "instruction": "Configure a device to collect API execution statistics data.",
        "input": "",
        "output": "SetStatistic (bool enable)"
    },
    {
        "instruction": "Read the currently collected API execution statistics data.",
        "input": "",
        "output": "GetStatistic (DeviceStatistics *statistics)"
    },
    {
        "instruction": "Set the interrupt (cyclic handler) associated with the calling device.",
        "input": "",
        "output": "SetInterruptId (unsigned int interruptId)"
    },
    {
        "instruction": "Get the interrupt (cyclic handler) associated with the calling device.",
        "input": "",
        "output": "GetInterruptId (unsigned int *interruptId)"
    },
    {
        "instruction": "Start communication with the servo network.",
        "input": "",
        "output": "StartCommunication (unsigned int waitTimeMilliseconds=0)"
    },
    {
        "instruction": "Stop communication with the servo network.",
        "input": "",
        "output": "StopCommunication (unsigned int waitTimeMilliseconds=0)"
    },
    {
        "instruction": "Obtain information of the modules that are loaded by the engine.",
        "input": "",
        "output": "GetModulesInfo (ModulesInfoA *modules)"
    },
    {
        "instruction": "Obtain information of the modules that are loaded by the engine.",
        "input": "",
        "output": "GetModulesInfo (ModulesInfoW *modules)"
    },
    {
        "instruction": "Obtain information of a single module that is loaded by the engine.",
        "input": "",
        "output": "GetModuleInfo (int moduleId, ModuleInfoA *module)"
    },
    {
        "instruction": "Obtain information of a single module that is loaded by the engine.",
        "input": "",
        "output": "GetModuleInfo (int moduleId, ModuleInfoW *module)"
    },
    {
        "instruction": "Obtain the status of the engine.",
        "input": "",
        "output": "GetEngineStatus (EngineStatus *status)"
    },
    {
        "instruction": "Obtain information of all existing devices.",
        "input": "",
        "output": "GetAllDevices (DevicesInfoA *devices)"
    },
    {
        "instruction": "Obtain information of all existing devices.",
        "input": "",
        "output": "GetAllDevices (DevicesInfoW *devices)"
    },
    {
        "instruction": "Set the name of this device. ",
        "input": "",
        "output": "SetDeviceName (const char *name)"
    },
    {
        "instruction": "Set the name of this device. ",
        "input": "",
        "output": "SetDeviceName (const wchar_t *name)"
    },
    {
        "instruction": "Get the name of this device.",
        "input": "",
        "output": "GetDeviceName (char *nameBuf, unsigned int bufSize)"
    },
    {
        "instruction": "Get the name of this device.",
        "input": "",
        "output": "GetDeviceName (wchar_t *nameBuf, unsigned int bufSize)"
    },
    {
        "instruction": "Reserved.",
        "input": "",
        "output": "SetDeviceWaitEvent (int errCode)"
    },
    {
        "instruction": "Reserved.",
        "input": "",
        "output": "ResetDeviceWaitEvent ()"
    },
    {
        "instruction": "Reserved.",
        "input": "",
        "output": "WaitForDeviceWaitEvent (unsigned int waitTime, int *errCode)"
    },
    {
        "instruction": "Set whether to suspend loading specific platform modules when starting communication.",
        "input": "",
        "output": "SetModuleSuspend (ModuleSuspend *suspend)"
    },
    {
        "instruction": "Get the settings of whether to suspend loading specific platform modules when starting communication.",
        "input": "",
        "output": "GetModuleSuspend (ModuleSuspend *suspend)"
    },
    {
        "instruction": "Clear all settings of whether to suspend loading specific platform modules when starting communication. ",
        "input": "",
        "output": "AbortModuleSuspend ()"
    },
    {
        "instruction": "Pauses execution of the current thread until the specified timeout interval elapses.",
        "input": "",
        "output": "SleepAtEngine (unsigned long microSecond)"
    },
    {
        "instruction": "Print a message to the Console Screen.",
        "input": "",
        "output": "PrintToServerConsole (const char *format,...)"
    },
    {
        "instruction": "Print a message to the Console Screen.",
        "input": "",
        "output": "PrintToServerConsole (const wchar_t *format,...)"
    },
    {
        "instruction": "Record a list of installed Windows Updates to file. ",
        "input": "",
        "output": "RecordWindowsUpdates (unsigned int waitTimeMilliseconds=0)"
    },
    {
        "instruction": "Compare the list of currently installed Windows Updates to the list recorded to file. ",
        "input": "",
        "output": "CompareWindowsUpdates (unsigned int waitTimeMilliseconds=0)"
    },
    {
        "instruction": "Get a string representation of the specified error code. ",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code. ",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Get the version of the IMDll. ",
        "input": "",
        "output": "GetIMDllVersion (int *pVersion, int *pRevision)"
    },
    {
        "instruction": "Append a string to a file. ",
        "input": "",
        "output": "PrintToFile (const char *filePath, const char *format,...)"
    },
    {
        "instruction": "Append a string to a file. ",
        "input": "",
        "output": "PrintToFile (const wchar_t *filePath, const wchar_t *format,...)"
    },
    {
        "instruction": "Append a string to a file.",
        "input": "",
        "output": "PrintToFile (const char *filePath, int charsToPrint, const char *buff)"
    },
    {
        "instruction": "Append a string to a file. ",
        "input": "",
        "output": "PrintToFile (const wchar_t *filePath, int charsToPrint, const wchar_t *buff)"
    },
    {
        "instruction": "Append a string to a file.",
        "input": "",
        "output": "PrintToFileIfExist (const char *filePath, const char *format,...)"
    },
    {
        "instruction": "Append a string to a file.",
        "input": "",
        "output": "PrintToFileIfExist (const wchar_t *filePath, const wchar_t *format,...)"
    },
    {
        "instruction": "Append a string to a file. ",
        "input": "",
        "output": "PrintToFileIfExist (const char *filePath, int charsToPrint, const char *buff)"
    },
    {
        "instruction": "Append a string to a file.",
        "input": "",
        "output": "PrintToFileIfExist (const wchar_t *filePath, int charsToPrint, const wchar_t *buff)"
    },
    {
        "instruction": "Get the character string stored in the WMX3 engine message output buffer. ",
        "input": "",
        "output": "GetStdOutStr (char *buff, int buffSize, unsigned char *isWideChar, int *strlen)"
    },
    {
        "instruction": "Get the size of the string stored in the WMX3 engine message output buffer. ",
        "input": "",
        "output": "GetStdOutDataSize ()"
    },
    {
        "instruction": "Clear the string stored in the WMX3 engine message output buffer.",
        "input": "",
        "output": "ClearStdOut ()"
    },
    {
        "instruction": "Release resources related to the WMX3 engine message output buffer.",
        "input": "",
        "output": "ReleaseStdOut ()"
    },
    {
        "instruction": "Reserved.",
        "input": "",
        "output": "dev"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions. Also see Devices. ",
        "input": "",
        "output": "CoreMotion (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class. Also see Copy Operators. ",
        "input": "",
        "output": "CoreMotion (const CoreMotion &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class. Also see Copy Operators.",
        "input": "",
        "output": "CoreMotion & operator= (const CoreMotion &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device. Also see Self Devices. ",
        "input": "",
        "output": "CoreMotion ()"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~CoreMotion ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Read the current system status from the engine.",
        "input": "",
        "output": "GetStatus (CoreMotionStatus *status)"
    },
    {
        "instruction": "Clear the vibration measurement statuses of an axis.",
        "input": "",
        "output": "ClearVibrationStatus (int axis)"
    },
    {
        "instruction": "Clear the vibration measurement statuses of multiple axes. ",
        "input": "",
        "output": "ClearVibrationStatus (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Initiate an emergency stop to stop the motion of all axes.",
        "input": "",
        "output": "ExecEStop (EStopLevel::T level)"
    },
    {
        "instruction": "Clear the emergency stop state to allow the axes to be controlled again.",
        "input": "",
        "output": "ReleaseEStop ()"
    },
    {
        "instruction": "Trigger the flight recorder to write the flight recorder data to file.",
        "input": "",
        "output": "TriggerFlightRecorder ()"
    },
    {
        "instruction": "Reset the flight recorder so that it may be triggered again.",
        "input": "",
        "output": "ResetFlightRecorder ()"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log. ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library. ",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "This class contains axis control functions. ",
        "input": "",
        "output": "AxisControl (CoreMotion *f)"
    },
    {
        "instruction": "Turn a servo drive in the servo network on or off. ",
        "input": "",
        "output": "SetServoOn (int axis, int newStatus)"
    },
    {
        "instruction": "Turn multiple servo drives in the servo network on or off.",
        "input": "",
        "output": "SetServoOn (AxisSelection *pAxisSelection, int newStatus)"
    },
    {
        "instruction": "Clear the servo drive amp alarm on the specified axis. ",
        "input": "",
        "output": "ClearAmpAlarm (int axis)"
    },
    {
        "instruction": "Clear the servo drive amp alarms on multiple axes. ",
        "input": "",
        "output": "ClearAmpAlarm (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Clear any axis alarms on the specified axis.",
        "input": "",
        "output": "ClearAxisAlarm (int axis)"
    },
    {
        "instruction": "Clear any axis alarms on multiple axes. ",
        "input": "",
        "output": "ClearAxisAlarm (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Set the command mode of the axis.",
        "input": "",
        "output": "SetAxisCommandMode (int axis, AxisCommandMode::T mode)"
    },
    {
        "instruction": "Set the command mode of multiple axes. ",
        "input": "",
        "output": "SetAxisCommandMode (AxisSelection *pAxisSelection, AxisCommandMode::T mode)"
    },
    {
        "instruction": "Get the command mode of the axis. ",
        "input": "",
        "output": "GetAxisCommandMode (int axis, AxisCommandMode::T *pMode)"
    },
    {
        "instruction": "Get the current cycle position command of the axis. ",
        "input": "",
        "output": "GetPosCommand (int axis, double *pPosition)"
    },
    {
        "instruction": "Get the current cycle position feedback of the axis.",
        "input": "",
        "output": "GetPosFeedback (int axis, double *pPosition)"
    },
    {
        "instruction": "Get the current cycle velocity command of the axis",
        "input": "",
        "output": "GetVelCommand (int axis, double *pVelocity)"
    },
    {
        "instruction": "Get the current cycle velocity feedback of the axis",
        "input": "",
        "output": "GetVelFeedback (int axis, double *pVelocity)"
    },
    {
        "instruction": "This class contains alarm parameters of an axis. See Alarm Parameters for a description of each parameter",
        "input": "",
        "output": "AlarmParam"
    },
    {
        "instruction": "This class contains parameters specific to an axis. See Axis Parameters for a description of each parameter.",
        "input": "",
        "output": "AxisParam"
    },
    {
        "instruction": "This enumerator class enumerates the circular interpolation override types. The circular interpolation override type determines the method by which a circular interpolation overrides another linear or circular interpolation. ",
        "input": "",
        "output": "CircularIntplOverrideType"
    },
    {
        "instruction": "This class contains emergency stop parameters. See Emergency Stop Parameters for a description of each parameter. ",
        "input": "",
        "output": "EmergencyStopParam"
    },
    {
        "instruction": "This enumerator class enumerates the actions to take when a level 1 emergency stop is triggered. ",
        "input": "",
        "output": "EStopLevel1Type"
    },
    {
        "instruction": "This enumerator class enumerates the sources of an emergency stop signal. ",
        "input": "",
        "output": "EStopSignalSource"
    },
    {
        "instruction": "This enumerator class enumerates the destinations of an emergency stop status signal.",
        "input": "",
        "output": "EStopStatusSignalDestination"
    },
    {
        "instruction": "This class contains feedback parameters of an axis. See Feedback Parameters for a description of each parameter.",
        "input": "",
        "output": "FeedbackParam"
    },
    {
        "instruction": "This class contains flight recorder parameters. See Flight Recorder Parameters for a description of each parameter.",
        "input": "",
        "output": "FlightRecorderParam"
    },
    {
        "instruction": "This enumerator class enumerates the actions to take when a following error alarm occurs (when the difference between the position command and feedback exceeds a set value).",
        "input": "",
        "output": "FollowingErrorAlarmType"
    },
    {
        "instruction": "This enumerator class enumerates the directions of homing.",
        "input": "",
        "output": "HomeDirection"
    },
    {
        "instruction": "This class contains home parameters of an axis. See Homing Parameters for a description of each parameter.",
        "input": "",
        "output": "HomeParam"
    },
    {
        "instruction": "This enumerator class enumerates the home types. The home type determines the method by which the axis searches for the home position. Also see Homing for a more detailed description of each home type. ",
        "input": "",
        "output": "HomeType"
    },
    {
        "instruction": "This class contains limit parameters of an axis. See Limit Parameters for a description of each parameter.",
        "input": "",
        "output": "LimitParam"
    },
    {
        "instruction": "This enumerator class enumerates the limit switch directions. The limit switch direction indicates whether the limit switches are attached in the normal direction or the reverse direction.",
        "input": "",
        "output": "LimitSwitchDirection"
    },
    {
        "instruction": "This enumerator class enumerates the limit switch types. The limit switch type determines the action to take when the limit switch of an axis is triggered.",
        "input": "",
        "output": "LimitSwitchType"
    },
    {
        "instruction": "This enumerator class enumerates the linear interpolation override types. The linear interpolation override type determines the method by which a linear interpolation overrides another linear or circular interpolation. ",
        "input": "",
        "output": "LinearIntplOverrideType"
    },
    {
        "instruction": "This enumerator class enumerates the linear interpolation profile calculation modes. This parameter determines how the profile parameters (velocity, acceleration, etc.) for linear interpolation are calculated from the maxVelocity, maxAcc, maxDec, maxJerkAcc, and maxJerkDec specified for each interpolating axis. ",
        "input": "",
        "output": "LinearIntplProfileCalcMode"
    },
    {
        "instruction": "This enumerator class enumerates the actions to take for the master axis when one of the slave axes becomes de-synchronized.",
        "input": "",
        "output": "MasterDesyncType"
    },
    {
        "instruction": "This class contains motion parameters of an axis. See Motion Parameters for a description of each parameter.",
        "input": "",
        "output": "MotionParam"
    },
    {
        "instruction": "This enumerator class enumerates the prohibit overtravel types. Depending on this parameter, profile parameters (such as velocity, deceleration, etc.) may be changed from the specified values to prevent overtravel beyond the target position. ",
        "input": "",
        "output": "ProhibitOvertravelType"
    },
    {
        "instruction": "This enumerator class enumerates the actions to take for the slave axis when the master axis becomes de-synchronized. ",
        "input": "",
        "output": "SlaveDesyncType"
    },
    {
        "instruction": "This enumerator class enumerates the sync compensation modes. The sync compensation mode determines any compensation to apply to improve the sync control between the master and slave axes.",
        "input": "",
        "output": "SyncCompensationMode"
    },
    {
        "instruction": "This class contains sync parameters of an axis. See Sync Parameters for a description of each parameter.",
        "input": "",
        "output": "SyncParam"
    },
    {
        "instruction": "This class contains system parameters for the entire system. See Parameters for a description of each parameter.",
        "input": "",
        "output": "SystemParam"
    },
    {
        "instruction": "This enumerator class enumerates the actions to take when a velocity following error alarm occurs (when the difference between the velocity command and feedback exceeds a set value). ",
        "input": "",
        "output": "VelocityFollowingErrorAlarmType"
    },
    {
        "instruction": "This enumerator class specifies the source for the actual velocity status.",
        "input": "",
        "output": "VelocityMonitorSource"
    },
    {
        "instruction": "This class contains configuration functions. ",
        "input": "",
        "output": "Config (CoreMotion *f)"
    },
    {
        "instruction": "Set system parameter settings for all axes.",
        "input": "",
        "output": "SetParam (SystemParam *pParam, SystemParam *pParamError=NULL)"
    },
    {
        "instruction": "Get system parameter settings for all axes.",
        "input": "",
        "output": "GetParam (SystemParam *pParam)"
    },
    {
        "instruction": "Set system parameter settings for a single axis. ",
        "input": "",
        "output": "SetParam (int axis, SystemParam *pParam, SystemParam *pParamError=NULL)"
    },
    {
        "instruction": "Get system parameter settings for a single axis.",
        "input": "",
        "output": "GetParam (int axis, SystemParam *pParam)"
    },
    {
        "instruction": "Set axis parameters for all axes. ",
        "input": "",
        "output": "SetAxisParam (AxisParam *pParam, AxisParam *pParamError=NULL)"
    },
    {
        "instruction": "Get axis parameters for all axes.",
        "input": "",
        "output": "GetAxisParam (AxisParam *pParam)"
    },
    {
        "instruction": "Set axis parameters for a single axis. ",
        "input": "",
        "output": "SetAxisParam (int axis, AxisParam *pParam, AxisParam *pParamError=NULL)"
    },
    {
        "instruction": "Get axis parameters for a single axis. ",
        "input": "",
        "output": "GetAxisParam (int axis, AxisParam *pParam)"
    },
    {
        "instruction": "Set the gear ratio of the axis. ",
        "input": "",
        "output": "SetGearRatio (int axis, double numerator, double denominator)"
    },
    {
        "instruction": "Set the single turn mode and single turn encoder count of an axis.",
        "input": "",
        "output": "SetSingleTurn (int axis, bool enable, unsigned int encoderCount)"
    },
    {
        "instruction": "Set the moving average profile time parameter for an axis.",
        "input": "",
        "output": "SetMovingAverageProfileTime (int axis, double milliseconds)"
    },
    {
        "instruction": "Set the axis unit parameter for an axis. ",
        "input": "",
        "output": "SetAxisUnit (int axis, double unit)"
    },
    {
        "instruction": "Set the velocity feedforward gain parameter for an axis.",
        "input": "",
        "output": "SetVelocityFeedforwardGain (int axis, double gain)"
    },
    {
        "instruction": "Set the axis polarity for an axis.",
        "input": "",
        "output": "SetAxisPolarity (int axis, char polarity)"
    },
    {
        "instruction": "Set the absolute encoder mode for an axis. ",
        "input": "",
        "output": "SetAbsoluteEncoderMode (int axis, bool enable)"
    },
    {
        "instruction": "Set the absolute encoder home offset for an axis.",
        "input": "",
        "output": "SetAbsoluteEncoderHomeOffset (int axis, double offset)"
    },
    {
        "instruction": "Set the encoder range mode and encoder range for an axis",
        "input": "",
        "output": "SetEncoderRange (int axis, bool enable, int encoderRangeLow, int encoderRangeHigh)"
    },
    {
        "instruction": "Get the gear ratio of the axis. ",
        "input": "",
        "output": "GetGearRatio (int axis, double *pNumerator, double *pDenominator)"
    },
    {
        "instruction": "Get the single turn mode and single turn encoder count of an axis. ",
        "input": "",
        "output": "GetSingleTurn (int axis, bool *pEnable, unsigned int *pEncoderCount)"
    },
    {
        "instruction": "Get the moving average profile time parameter of an axis. ",
        "input": "",
        "output": "GetMovingAverageProfileTime (int axis, double *pMilliseconds)"
    },
    {
        "instruction": "Get the axis unit parameter of an axis. ",
        "input": "",
        "output": "GetAxisUnit (int axis, double *pUnit)"
    },
    {
        "instruction": "Get the velocity feedforward gain of an axis.",
        "input": "",
        "output": "GetVelocityFeedforwardGain (int axis, double *pGain)"
    },
    {
        "instruction": "Get the axis polarity of an axis.",
        "input": "",
        "output": "GetAxisPolarity (int axis, char *pPolarity)"
    },
    {
        "instruction": "Get the absolute encoder mode of an axis. ",
        "input": "",
        "output": "GetAbsoluteEncoderMode (int axis, bool *pEnable)"
    },
    {
        "instruction": "Get the absolute encoder home offset of an axis.",
        "input": "",
        "output": "GetAbsoluteEncoderHomeOffset (int axis, double *pOffset)"
    },
    {
        "instruction": "Get the encoder range mode and encoder range of an axis. ",
        "input": "",
        "output": "GetEncoderRange (int axis, bool *pEnable, int *pEncoderRangeLow, int *pEncoderRangeHigh)"
    },
    {
        "instruction": "Set feedback parameter settings for an axis.",
        "input": "",
        "output": "SetFeedbackParam (int axis, FeedbackParam *pParam, FeedbackParam *pParamError=NULL)"
    },
    {
        "instruction": "Set home parameter settings for an axis. ",
        "input": "",
        "output": "SetHomeParam (int axis, HomeParam *pParam, HomeParam *pParamError=NULL)"
    },
    {
        "instruction": "Set limit parameter settings for an axis. ",
        "input": "",
        "output": "SetLimitParam (int axis, LimitParam *pParam, LimitParam *pParamError=NULL)"
    },
    {
        "instruction": "Set motion parameter settings for an axis. ",
        "input": "",
        "output": "SetMotionParam (int axis, MotionParam *pParam, MotionParam *pParamError=NULL)"
    },
    {
        "instruction": "Set alarm parameter settings for an axis. ",
        "input": "",
        "output": "SetAlarmParam (int axis, AlarmParam *pParam, AlarmParam *pParamError=NULL)"
    },
    {
        "instruction": "Set sync parameter settings for an axis. ",
        "input": "",
        "output": "SetSyncParam (int axis, SyncParam *pParam, SyncParam *pParamError=NULL)"
    },
    {
        "instruction": "Set flight recorder parameters.",
        "input": "",
        "output": "SetFlightRecorderParam (FlightRecorderParam *pParam, FlightRecorderParam *pParamError=NULL)"
    },
    {
        "instruction": "Set the file path to save the flight recorder data to. ",
        "input": "",
        "output": "SetFlightRecorderPath (char *pPath)"
    },
    {
        "instruction": "Set the file path to save the flight recorder data to. ",
        "input": "",
        "output": "SetFlightRecorderPath (wchar_t *pPath)"
    },
    {
        "instruction": "Set emergency stop parameters.",
        "input": "",
        "output": "SetEmergencyStopParam (EmergencyStopParam *pParam, EmergencyStopParam *pParamError=NULL)"
    },
    {
        "instruction": "Get feedback parameter settings for an axis.",
        "input": "",
        "output": "GetFeedbackParam (int axis, FeedbackParam *pParam)"
    },
    {
        "instruction": "Get home parameter settings for an axis. ",
        "input": "",
        "output": "GetHomeParam (int axis, HomeParam *pParam)"
    },
    {
        "instruction": "Get limit switch parameter settings for an axis",
        "input": "",
        "output": "GetLimitParam (int axis, LimitParam *pParam)"
    },
    {
        "instruction": "Get motion parameter settings for an axis. ",
        "input": "",
        "output": "GetMotionParam (int axis, MotionParam *pParam)"
    },
    {
        "instruction": "Get alarm parameter settings for an axis. ",
        "input": "",
        "output": "GetAlarmParam (int axis, AlarmParam *pParam)"
    },
    {
        "instruction": "Get the sync parameters of the axis. ",
        "input": "",
        "output": "GetSyncParam (int axis, SyncParam *pParam)"
    },
    {
        "instruction": "Get flight recorder parameters.",
        "input": "",
        "output": "GetFlightRecorderParam (FlightRecorderParam *pParam)"
    },
    {
        "instruction": "Get emergency stop parameters.",
        "input": "",
        "output": "GetEmergencyStopParam (EmergencyStopParam *pParam)"
    },
    {
        "instruction": "Get the default system parameters. ",
        "input": "",
        "output": "GetDefaultParam (SystemParam *pParam)"
    },
    {
        "instruction": "Get the default axis parameters.",
        "input": "",
        "output": "GetDefaultAxisParam (AxisParam *pAxisParam)"
    },
    {
        "instruction": "Export system parameters to an xml file. ",
        "input": "",
        "output": "Export (char *pPath, SystemParam *pParam)"
    },
    {
        "instruction": "Export system parameters to an xml file. ",
        "input": "",
        "output": "Export (wchar_t *pPath, SystemParam *pParam)"
    },
    {
        "instruction": "Export axis parameters to an xml file. ",
        "input": "",
        "output": "Export (char *pPath, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Export axis parameters to an xml file. ",
        "input": "",
        "output": "Export (wchar_t *pPath, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Export system and axis parameters to an xml file. ",
        "input": "",
        "output": "Export (char *pPath, SystemParam *pParam, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Export system and axis parameters to an xml file. ",
        "input": "",
        "output": "Export (wchar_t *pPath, SystemParam *pParam, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Export system parameters of one axis to an xml file.",
        "input": "",
        "output": "Export (char *pPath, SystemParam *pParam, int axis)"
    },
    {
        "instruction": "Export system parameters of one axis to an xml file.",
        "input": "",
        "output": "Export (wchar_t *pPath, SystemParam *pParam, int axis)"
    },
    {
        "instruction": "Export axis parameters of one axis to an xml file. ",
        "input": "",
        "output": "Export (char *pPath, AxisParam *pAxisParam, int axis)"
    },
    {
        "instruction": "Export system and axis parameters of one axis to an xml file.",
        "input": "",
        "output": "Export (wchar_t *pPath, SystemParam *pParam, AxisParam *pAxisParam, int axis)"
    },
    {
        "instruction": "Import system parameters from an xml file. ",
        "input": "",
        "output": "Import (char *pPath, SystemParam *pParam)"
    },
    {
        "instruction": "Import system parameters from an xml file. ",
        "input": "",
        "output": "Import (wchar_t *pPath, SystemParam *pParam)"
    },
    {
        "instruction": "Import axis parameters from an xml file. ",
        "input": "",
        "output": "Import (char *pPath, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Import axis parameters from an xml file. ",
        "input": "",
        "output": "Import (wchar_t *pPath, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Import system and axis parameters from an xml file. ",
        "input": "",
        "output": "Import (char *pPath, SystemParam *pParam, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Import system and axis parameters from an xml file. ",
        "input": "",
        "output": "Import (wchar_t *pPath, SystemParam *pParam, AxisParam *pAxisParam)"
    },
    {
        "instruction": "Import system parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (char *pPath, SystemParam *pParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Import system parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (wchar_t *pPath, SystemParam *pParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Import axis parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (char *pPath, AxisParam *pAxisParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Import axis parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (wchar_t *pPath, AxisParam *pAxisParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Import system and axis parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (char *pPath, SystemParam *pParam, AxisParam *pAxisParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Import system and axis parameters of one axis from an xml file.",
        "input": "",
        "output": "Import (wchar_t *pPath, SystemParam *pParam, AxisParam *pAxisParam, int axis, AxisSelection *copyParamToAxes=NULL)"
    },
    {
        "instruction": "Get the current parameters for all axes and export them to an xml file. ",
        "input": "",
        "output": "GetAndExportAll (char *pPath)"
    },
    {
        "instruction": "Get the current parameters for all axes and export them to an xml file. ",
        "input": "",
        "output": "GetAndExportAll (wchar_t *pPath)"
    },
    {
        "instruction": "Imports parameters from an xml file and set them as the current parameters for all axes. ",
        "input": "",
        "output": "ImportAndSetAll (char *pPath, SystemParam *pParamError=NULL, AxisParam *pAxisParamError=NULL)"
    },
    {
        "instruction": "Imports parameters from an xml file and set them as the current parameters for all axes. ",
        "input": "",
        "output": "ImportAndSetAll (wchar_t *pPath, SystemParam *pParamError=NULL, AxisParam *pAxisParamError=NULL)"
    },
    {
        "instruction": "This class contains homing functions. ",
        "input": "",
        "output": "Home (CoreMotion *f)"
    },
    {
        "instruction": "This class contains homing related data for a single axis.",
        "input": "",
        "output": "AxisHomeData"
    },
    {
        "instruction": "This class contains homing related data for all axes.",
        "input": "",
        "output": "HomeData"
    },
    {
        "instruction": "Start homing an axis. The axis will search for the home position. If found, the home position will become the zero position for that axis.",
        "input": "",
        "output": "StartHome (int axis)"
    },
    {
        "instruction": "Start homing multiple axes. The axes will search for the home positions. If found, the home position will become the zero position for that axis",
        "input": "",
        "output": "StartHome (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Continue homing an axis that has been paused during the homing operation. ",
        "input": "",
        "output": "Continue (int axis)"
    },
    {
        "instruction": "Continue homing multiple axes that have been paused during the homing operation. ",
        "input": "",
        "output": "Continue (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Cancel the homing operation for an axis that has been paused during homing operation.",
        "input": "",
        "output": "Cancel (int axis)"
    },
    {
        "instruction": "Cancel the homing procedure for multiple axes that have been paused during homing operation",
        "input": "",
        "output": "Cancel (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Set the current command position of the axis to the specified value. ",
        "input": "",
        "output": "SetCommandPos (int axis, double position)"
    },
    {
        "instruction": "Set the current feedback position of the axis to the specified value. ",
        "input": "",
        "output": "SetFeedbackPos (int axis, double position)"
    },
    {
        "instruction": "Set the \"home done\" state. ",
        "input": "",
        "output": "SetHomeDone (int axis, unsigned char value)"
    },
    {
        "instruction": "Set the current cyclic command position equal to the feedback position.",
        "input": "",
        "output": "SetCommandPosToFeedbackPos (int axis, double posChangePerCycle=0)"
    },
    {
        "instruction": "Get the homing related data for all axes. ",
        "input": "",
        "output": "GetHomeData (HomeData *pHomeData)"
    },
    {
        "instruction": "This class contains position command functions. ",
        "input": "",
        "output": "Motion (CoreMotion *f)"
    },
    {
        "instruction": "This class contains additional AT (Acceleration-Time) point data",
        "input": "",
        "output": "ATAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a AT (Acceleration-Time) command.",
        "input": "",
        "output": "ATCommand"
    },
    {
        "instruction": "This class contains data for a AT (Acceleration-Time) point.",
        "input": "",
        "output": "ATPoint"
    },
    {
        "instruction": "This class contains data for a circular interpolation motion command that is specified by the center and end positions.",
        "input": "",
        "output": "CenterAndEndCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for a circular interpolation motion command that is specified by the center position and arc length.",
        "input": "",
        "output": "CenterAndLengthCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for a helical interpolation motion command. A helical interpolation combines a circular interpolation with a linear interpolation so that the resulting motion is a three-dimensional helix. The helix is defined by the center position and arc length of the circular interpolation and the end position of the linear interpolation. The linear interpolation must be along only one axis, and the circular interpolation must be along two other axes. ",
        "input": "",
        "output": "HelicalIntplCommand"
    },
    {
        "instruction": "This enumerator class enumerates the types of ways to specify the profile for a helical interpolation.",
        "input": "",
        "output": "HelicalIntplProfileType"
    },
    {
        "instruction": "This class contains data for a jog command.",
        "input": "",
        "output": "JogCommand"
    },
    {
        "instruction": "This class contains data for a circular interpolation motion command that is specified by the end position and arc length.",
        "input": "",
        "output": "LengthAndEndCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for a linear interpolation motion command.",
        "input": "",
        "output": "LinearIntplCommand"
    },
    {
        "instruction": "This class contains data for a position command.",
        "input": "",
        "output": "PosCommand"
    },
    {
        "instruction": "This class contains data for a position to jog command.",
        "input": "",
        "output": "PosToJogCommand"
    },
    {
        "instruction": "This class contains additional PT (Position-Time) point data.",
        "input": "",
        "output": "PTAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a PT (Position-Time) command.",
        "input": "",
        "output": "PTCommand"
    },
    {
        "instruction": "This class contains data for a PT (Position-Time) point.",
        "input": "",
        "output": "PTPoint"
    },
    {
        "instruction": "This class contains additional PVT (Position-Velocity-Time) point data.",
        "input": "",
        "output": "PVTAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a PVT (Position-Velocity-Time) command.",
        "input": "",
        "output": "PVTCommand"
    },
    {
        "instruction": "This class contains data for additional PVT (Position-Velocity-Time) interpolation point data for multiple axes",
        "input": "",
        "output": "PVTIntplAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a PVT (Position-Velocity-Time) interpolation command for multiple axes.",
        "input": "",
        "output": "PVTIntplCommand"
    },
    {
        "instruction": "This class contains data for a PVT (Position-Velocity-Time) point.",
        "input": "",
        "output": "PVTPoint"
    },
    {
        "instruction": "This class contains data for a circular interpolation motion command that is specified by the end position and arc radius. ",
        "input": "",
        "output": "RadiusAndEndCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for simulating a linear interpolation motion command. ",
        "input": "",
        "output": "SimulateLinearIntplCommand"
    },
    {
        "instruction": "This class contains data for simulating a single axis position command.",
        "input": "",
        "output": "SimulatePosCommand"
    },
    {
        "instruction": "This class contains data for a stop command.",
        "input": "",
        "output": "StopCommand"
    },
    {
        "instruction": "This class contains data for a three-dimensional circular interpolation motion command that is specified by the through and end positions. ",
        "input": "",
        "output": "ThroughAndEnd3DCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for a circular interpolation motion command that is specified by the through and end positions.",
        "input": "",
        "output": "ThroughAndEndCircularIntplCommand"
    },
    {
        "instruction": "This class contains data for a time-based command. ",
        "input": "",
        "output": "TimeCommand"
    },
    {
        "instruction": "This class contains data for a timed jog command. ",
        "input": "",
        "output": "TimedJogCommand"
    },
    {
        "instruction": "This class contains data for a triggered jog command. ",
        "input": "",
        "output": "TriggerJogCommand"
    },
    {
        "instruction": "This class contains data for a triggered position command.",
        "input": "",
        "output": "TriggerPosCommand"
    },
    {
        "instruction": "This class contains data for a triggered timed jog command.",
        "input": "",
        "output": "TriggerTimedJogCommand"
    },
    {
        "instruction": "This class contains additional VT (Velocity-Time) point data.",
        "input": "",
        "output": "VTAdditionalCommand"
    },
    {
        "instruction": "This class contains data for a VT (Velocity-Time) command. ",
        "input": "",
        "output": "VTCommand"
    },
    {
        "instruction": "This class contains data for a VT (Velocity-Time) point.",
        "input": "",
        "output": "VTPoint"
    },
    {
        "instruction": "This class describes a wait condition. ",
        "input": "",
        "output": "WaitCondition"
    },
    {
        "instruction": "This enumerator class enumerates the types of wait conditions.",
        "input": "",
        "output": "WaitConditionType"
    },
    {
        "instruction": "Start an absolute position command. ",
        "input": "",
        "output": "StartPos (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start a relative position command.",
        "input": "",
        "output": "StartMov (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start an absolute triggered position command.",
        "input": "",
        "output": "StartPos (TriggerPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start a relative triggered position command.",
        "input": "",
        "output": "StartMov (TriggerPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start an absolute triggered position command with multiple trigger events. ",
        "input": "",
        "output": "StartPos (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a relative triggered position command with multiple trigger events. ",
        "input": "",
        "output": "StartMov (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start absolute position commands for multiple axes. ",
        "input": "",
        "output": "StartPos (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start relative position commands for multiple axes.",
        "input": "",
        "output": "StartMov (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start absolute triggered position commands for multiple axes.",
        "input": "",
        "output": "StartPos (unsigned int numCommands, TriggerPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start relative triggered position commands for multiple axes.",
        "input": "",
        "output": "StartMov (unsigned int numCommands, TriggerPosCommand *pPosCommand)"
    },
    {
        "instruction": "Start absolute triggered position commands with multiple trigger events for multiple axes.",
        "input": "",
        "output": "StartPos (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start relative triggered position commands with multiple trigger events for multiple axes. ",
        "input": "",
        "output": "StartMov (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start an absolute position linear interpolation motion command.",
        "input": "",
        "output": "StartLinearIntplPos (LinearIntplCommand *pLinearIntplCommand)"
    },
    {
        "instruction": "Start a relative position linear interpolation motion command. ",
        "input": "",
        "output": "StartLinearIntplMov (LinearIntplCommand *pLinearIntplCommand)"
    },
    {
        "instruction": "Start an absolute position triggered linear interpolation motion command.",
        "input": "",
        "output": "StartLinearIntplPos (LinearIntplCommand *pLinearIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a relative position triggered linear interpolation motion command.",
        "input": "",
        "output": "StartLinearIntplMov (LinearIntplCommand *pLinearIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start an absolute position triggered linear interpolation motion command with multiple trigger events.",
        "input": "",
        "output": "StartLinearIntplPos (LinearIntplCommand *pLinearIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a relative position triggered linear interpolation motion command with multiple trigger events.",
        "input": "",
        "output": "StartLinearIntplMov (LinearIntplCommand *pLinearIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the absolute center position of the arc and the arc length. ",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndLengthCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the relative center position of the arc and the arc length.",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndLengthCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the absolute center and end positions of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the relative center and end positions of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the arc length and the absolute end position of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (LengthAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the arc length and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (LengthAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (RadiusAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (RadiusAndEndCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a three-dimensional circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a three-dimensional circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the absolute center position of the arc and the arc length.",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndLengthCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the relative center position of the arc and the arc length. ",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndLengthCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the absolute center and end positions of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the relative center and end positions of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc length and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (LengthAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc length and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (LengthAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (RadiusAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc radius and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (RadiusAndEndCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered three-dimensional circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered three-dimensional circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the absolute center position of the arc and the arc length.",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndLengthCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the relative center position of the arc and the arc length. ",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndLengthCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the absolute center and end positions of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (CenterAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the relative center and end positions of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (CenterAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc length and the absolute end position of the arc.",
        "input": "",
        "output": "StartCircularIntplPos (LengthAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc length and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (LengthAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc radius and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (RadiusAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc radius and the relative end position of the arc.",
        "input": "",
        "output": "StartCircularIntplMov (RadiusAndEndCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a three-dimensional triggered circular interpolation motion command with multiple trigger events. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplPos (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a three-dimensional triggered circular interpolation motion command with multiple trigger events. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc. ",
        "input": "",
        "output": "StartCircularIntplMov (ThroughAndEnd3DCircularIntplCommand *pCircularIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a helical interpolation motion command. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis.",
        "input": "",
        "output": "StartHelicalIntplPos (HelicalIntplCommand *pHelicalIntplCommand)"
    },
    {
        "instruction": "Start a helical interpolation motion command. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis. ",
        "input": "",
        "output": "StartHelicalIntplMov (HelicalIntplCommand *pHelicalIntplCommand)"
    },
    {
        "instruction": "Start a triggered helical interpolation motion command. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis. ",
        "input": "",
        "output": "StartHelicalIntplPos (HelicalIntplCommand *pHelicalIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered helical interpolation motion command. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis. ",
        "input": "",
        "output": "StartHelicalIntplMov (HelicalIntplCommand *pHelicalIntplCommand, Trigger *pTrigger)"
    },
    {
        "instruction": "Start a triggered helical interpolation motion command with multiple trigger events. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis.",
        "input": "",
        "output": "StartHelicalIntplPos (HelicalIntplCommand *pHelicalIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered helical interpolation motion command with multiple trigger events. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis. ",
        "input": "",
        "output": "StartHelicalIntplMov (HelicalIntplCommand *pHelicalIntplCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start an absolute triggered position command for an axis that is currently executing a velocity command.",
        "input": "",
        "output": "StartVelToPos (TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start a relative triggered position command for an axis that is currently executing a velocity command.",
        "input": "",
        "output": "StartVelToMov (TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start absolute triggered position commands for multiple axes that are currently executing velocity commands. ",
        "input": "",
        "output": "StartVelToPos (unsigned int numCommands, TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start relative triggered position commands for multiple axes that are currently executing velocity commands.",
        "input": "",
        "output": "StartVelToMov (unsigned int numCommands, TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start an absolute triggered position command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events. ",
        "input": "",
        "output": "StartVelToPos (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a relative triggered position command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events.",
        "input": "",
        "output": "StartVelToMov (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start absolute triggered position commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "input": "",
        "output": "StartVelToPos (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start relative triggered position commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "input": "",
        "output": "StartVelToMov (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start an absolute triggered position command for an axis that is currently executing a torque command. ",
        "input": "",
        "output": "StartTrqToPos (TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start a relative triggered position command for an axis that is currently executing a torque command.",
        "input": "",
        "output": "StartTrqToMov (TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start absolute triggered position commands for multiple axes that are currently executing torque commands. ",
        "input": "",
        "output": "StartTrqToPos (unsigned int numCommands, TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start relative triggered position commands for multiple axes that are currently executing torque commands.",
        "input": "",
        "output": "StartTrqToMov (unsigned int numCommands, TriggerPosCommand *pTriggerPosCommand)"
    },
    {
        "instruction": "Start an absolute triggered position command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToPos (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a relative triggered position command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToMov (PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start absolute triggered position commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToPos (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start relative triggered position commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToMov (unsigned int numCommands, PosCommand *pPosCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a jog command.",
        "input": "",
        "output": "StartJog (JogCommand *pJogCommand)"
    },
    {
        "instruction": "Start a timed jog command.",
        "input": "",
        "output": "StartJog (TimedJogCommand *pTimedJogCommand)"
    },
    {
        "instruction": "Start a triggered jog command. ",
        "input": "",
        "output": "StartJog (TriggerJogCommand *pJogCommand)"
    },
    {
        "instruction": "Start a triggered timed jog command. ",
        "input": "",
        "output": "StartJog (TriggerTimedJogCommand *pTimedJogCommand)"
    },
    {
        "instruction": "Start a triggered jog command with multiple trigger events.",
        "input": "",
        "output": "StartJog (JogCommand *pJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered timed jog command with multiple trigger events.",
        "input": "",
        "output": "StartJog (TimedJogCommand *pTimedJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start jog commands for multiple axes. ",
        "input": "",
        "output": "StartJog (unsigned int numCommands, JogCommand *pJogCommand)"
    },
    {
        "instruction": "Start timed jog commands for multiple axes.",
        "input": "",
        "output": "StartJog (unsigned int numCommands, TimedJogCommand *pTimedJogCommand)"
    },
    {
        "instruction": "Start triggered jog commands for multiple axes.",
        "input": "",
        "output": "StartJog (unsigned int numCommands, TriggerJogCommand *pJogCommand)"
    },
    {
        "instruction": "Start triggered timed jog commands for multiple axes. ",
        "input": "",
        "output": "StartJog (unsigned int numCommands, TriggerTimedJogCommand *pTimedJogCommand)"
    },
    {
        "instruction": "Start triggered jog commands with multiple trigger events for multiple axes.",
        "input": "",
        "output": "StartJog (unsigned int numCommands, JogCommand *pJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered timed jog commands with multiple trigger events for multiple axes.",
        "input": "",
        "output": "StartJog (unsigned int numCommands, TimedJogCommand *pTimedJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered jog command for an axis that is currently executing a position command.",
        "input": "",
        "output": "StartPosToJog (TriggerJogCommand *pTriggerJogCommand)"
    },
    {
        "instruction": "Start triggered jog commands for multiple axes that are currently executing position commands.",
        "input": "",
        "output": "StartPosToJog (JogCommand *pJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered jog command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events. ",
        "input": "",
        "output": "StartPosToJog (unsigned int numCommands, JogCommand *pJogCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start an absolute position command and a triggered jog command simultaneously. The position command will be overridden by the jog command when the trigger condition is satisfied. ",
        "input": "",
        "output": "StartPosToJog (PosToJogCommand *pPosToJogCommand)"
    },
    {
        "instruction": "Start an absolute position command and a triggered jog command simultaneously for multiple axes. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "input": "",
        "output": "StartPosToJog (unsigned int numCommands, PosToJogCommand *pPosToJogCommand)"
    },
    {
        "instruction": "Start a relative position command and a triggered jog command simultaneously. The position command will be overridden by the jog command when the trigger condition is satisfied. ",
        "input": "",
        "output": "StartMovToJog (PosToJogCommand *pPosToJogCommand)"
    },
    {
        "instruction": "Start a relative position command and a triggered jog command simultaneously for multiple axes. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "input": "",
        "output": "StartMovToJog (unsigned int numCommands, PosToJogCommand *pPosToJogCommand)"
    },
    {
        "instruction": "Stop the motion of an axis.",
        "input": "",
        "output": "Stop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes.",
        "input": "",
        "output": "Stop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop the motion of an axis using the specified deceleration and a trapezoidal profile.",
        "input": "",
        "output": "Stop (int axis, double dec)"
    },
    {
        "instruction": "Stop the motion of multiple axes using the specified decelerations and trapezoidal profiles.",
        "input": "",
        "output": "Stop (unsigned int numCommands, StopCommand *pStopCommand)"
    },
    {
        "instruction": "Stop the motion of an axis using the Quick Stop Dec parameter.",
        "input": "",
        "output": "ExecQuickStop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes using the Quick Stop Dec parameter.",
        "input": "",
        "output": "ExecQuickStop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop an axis that is currently in motion in the specified amount of time using a trapezoidal profile. ",
        "input": "",
        "output": "ExecTimedStop (int axis, double timeMilliseconds)"
    },
    {
        "instruction": "Stop multiple axes that are currently in motion in the specified amount of time using a trapezoidal profile",
        "input": "",
        "output": "ExecTimedStop (AxisSelection *pAxisSelection, double timeMilliseconds)"
    },
    {
        "instruction": "Stop multiple axes that are currently in motion in the specified amounts of time using a trapezoidal profile.",
        "input": "",
        "output": "ExecTimedStop (unsigned int numCommands, TimeCommand *pTimeCommand)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the axis becomes idle.",
        "input": "",
        "output": "Wait (int axis)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the axes become idle.",
        "input": "",
        "output": "Wait (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the specified wait condition becomes true. ",
        "input": "",
        "output": "Wait (WaitCondition *pWaitCondition)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the axis becomes idle or the wait time elapses. ",
        "input": "",
        "output": "Wait (int axis, unsigned int waitTimeMilliseconds)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the axes become idle.",
        "input": "",
        "output": "Wait (AxisSelection *pAxisSelection, unsigned int waitTimeMilliseconds)"
    },
    {
        "instruction": "Start a blocking wait command, returning only when the specified wait condition becomes true. ",
        "input": "",
        "output": "Wait (WaitCondition *pWaitCondition, unsigned int waitTimeMilliseconds)"
    },
    {
        "instruction": "Pause the execution of a position command or interpolation command. ",
        "input": "",
        "output": "Pause (int axis)"
    },
    {
        "instruction": "Pause the execution of a position command or interpolation command for multiple axes. ",
        "input": "",
        "output": "Pause (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Resume the execution of a paused position command or interpolation command.",
        "input": "",
        "output": "Resume (int axis)"
    },
    {
        "instruction": "Resume the execution of a paused position command or interpolation command for multiple axes.",
        "input": "",
        "output": "Resume (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Override the target position of an axis currently executing a position command. The target position is specified as an absolute position",
        "input": "",
        "output": "OverridePos (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the target position of an axis currently executing a position command. The target position is specified as a relative position.",
        "input": "",
        "output": "OverrideMov (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the velocity of an axis currently executing a position, jog, or velocity command. ",
        "input": "",
        "output": "OverrideVel (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the acceleration of an axis currently executing a position, jog, or velocity command",
        "input": "",
        "output": "OverrideAcc (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the deceleration of an axis currently executing a position, jog, or velocity command.",
        "input": "",
        "output": "OverrideDec (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the acceleration jerk of an axis currently executing a position, jog, or velocity command.",
        "input": "",
        "output": "OverrideJerkAcc (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the deceleration jerk of an axis currently executing a position, jog, or velocity command.",
        "input": "",
        "output": "OverrideJerkDec (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the entire profile of an axis currently executing a position, jog, or velocity command.",
        "input": "",
        "output": "OverrideProfile (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the target positions of multiple axes currently executing position commands. The target positions are specified as absolute positions.",
        "input": "",
        "output": "OverridePos (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the target positions of multiple axes currently executing position commands. The target positions are specified as relative positions.",
        "input": "",
        "output": "OverrideMov (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the velocities of multiple axes currently executing position, jog, or velocity commands. ",
        "input": "",
        "output": "OverrideVel (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the accelerations of multiple axes currently executing position, jog, or velocity commands.",
        "input": "",
        "output": "OverrideAcc (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the decelerations of multiple axes currently executing position, jog, or velocity commands. ",
        "input": "",
        "output": "OverrideDec (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the acceleration jerks of multiple axes currently executing position, jog, or velocity commands.",
        "input": "",
        "output": "OverrideJerkAcc (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the deceleration jerks of multiple axes currently executing position, jog, or velocity commands.",
        "input": "",
        "output": "OverrideJerkDec (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Override the entire profiles of multiple axes currently executing position, jog, or velocity commands.",
        "input": "",
        "output": "OverrideProfile (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Stop an axis executing a jog command at a timing that will cause the axis to stop at exactly the specified position.",
        "input": "",
        "output": "StopJogAtPos (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Stop multiple axes executing jog commands at timing that wil cause the axes to stop at exactly the specified positions. ",
        "input": "",
        "output": "StopJogAtPos (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start a relative position superimposed motion command. The superimposed motion command will execute on top of any other motion that the axis may already be executing. ",
        "input": "",
        "output": "SuperimposeMov (PosCommand *pPosCommand)"
    },
    {
        "instruction": "Start superimposed relative position commands for multiple axes. The superimposed motion commands will execute on top of any other motion that the axes may already be executing. ",
        "input": "",
        "output": "SuperimposeMov (unsigned int numCommands, PosCommand *pPosCommand)"
    },
    {
        "instruction": "Stop a superimposed motion.",
        "input": "",
        "output": "StopSuperimpose (int axis)"
    },
    {
        "instruction": "Stop the superimposed motion of multiple axes.",
        "input": "",
        "output": "StopSuperimpose (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Simulate a position command without moving any axes. The peak velocity, acceleration time, cruise time (the time the axis velocity is constant), deceleration time, and total profile time of the position command are returned.",
        "input": "",
        "output": "SimulatePos (SimulatePosCommand *pSimulatePosCommand, double *pPeakVelocity, double *pTotalTimeMilliseconds, double *pAccelerationTimeMilliseconds, double *pCruiseTimeMilliseconds, double *pDecelerationTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a linear interpolation motion command without moving any axes. The peak velocity, acceleration time, cruise time (the time the axis velocity is constant), deceleration time, and total profile time of the linear interpolation motion command are returned. ",
        "input": "",
        "output": "SimulateLinearIntplPos (SimulateLinearIntplCommand *pSimulateLinearIntplCommand, double *pPeakVelocity, double *pTotalTimeMilliseconds, double *pAccelerationTimeMilliseconds, double *pCruiseTimeMilliseconds, double *pDecelerationTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a position command without moving any axes. The position and velocity of the axis after the motion command runs for the specified time are returned. ",
        "input": "",
        "output": "SimulatePosAtTime (SimulatePosCommand *pSimulatePosCommand, int returnType, double timeMilliseconds, double *pCalculatedPos, double *pCalculatedVel)"
    },
    {
        "instruction": "Simulate a linear interpolation motion command without moving any axes. The move distance, remain distance, and total distance after the linear interpolation runs for a specified amount of time are returned.",
        "input": "",
        "output": "SimulatePosAtTime (SimulateLinearIntplCommand *pSimulateLinearIntplCommand, double timeMilliseconds, double *pPosArray, double *pMoveDistance, double *pRemainDistance, double *pTotalDistance)"
    },
    {
        "instruction": "Simulate a position command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned. ",
        "input": "",
        "output": "SimulateTimeAtPos (SimulatePosCommand *pSimulatePosCommand, double specificPos, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds)"
    },
    {
        "instruction": "Simulate a linear interpolation motion command without moving any axes. The move time, remain time, and total time after the linear interpolation runs for a specified distance are returned. ",
        "input": "",
        "output": "SimulateTimeAtDist (SimulateLinearIntplCommand *pSimulateLinearIntplCommand, double specificDistance, double *pMoveTimeMilliseconds, double *pRemainTimeMilliseconds, double *pTotalTimeMilliseconds)"
    },
    {
        "instruction": "Allocate buffer memory to an axis for the execution of PVT motion commands. ",
        "input": "",
        "output": "CreatePVTBuffer (int axis, unsigned int points)"
    },
    {
        "instruction": "Free PVT buffer memory for an axis. ",
        "input": "",
        "output": "FreePVTBuffer (int axis)"
    },
    {
        "instruction": "Get the amount of PVT buffer memory currently allocated to an axis.",
        "input": "",
        "output": "GetPVTBufferPoints (int axis, unsigned int *pPoints)"
    },
    {
        "instruction": "Get the number of bytes required per point data in the PVT buffer memory.",
        "input": "",
        "output": "GetPVTBytesPerPoint (unsigned int *pBytes)"
    },
    {
        "instruction": "Start executing a PVT motion command. ",
        "input": "",
        "output": "StartPVT (PVTCommand *pPVTCommand, unsigned int numAddlCommands=0, PVTAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PVT motion command.",
        "input": "",
        "output": "StartPVT (PVTCommand *pPVTCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PVTAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PVT motion command with multiple trigger events. ",
        "input": "",
        "output": "StartPVT (PVTCommand *pPVTCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PVTAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a PVT interpolation motion command.",
        "input": "",
        "output": "StartPVT (PVTIntplCommand *pPVTCommand, unsigned int numAddlCommands=0, PVTIntplAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PVT interpolation motion command.",
        "input": "",
        "output": "StartPVT (PVTIntplCommand *pPVTCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PVTIntplAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PVT interpolation motion command with multiple trigger events.",
        "input": "",
        "output": "StartPVT (PVTIntplCommand *pPVTCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PVTIntplAdditionalCommand *pPVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a PT motion command. ",
        "input": "",
        "output": "StartPT (PTCommand *pPTCommand, unsigned int numAddlCommands=0, PTAdditionalCommand *pPTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PT motion command. ",
        "input": "",
        "output": "StartPT (PTCommand *pPTCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, PTAdditionalCommand *pPTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered PT motion command with multiple trigger events. ",
        "input": "",
        "output": "StartPT (PTCommand *pPTCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, PTAdditionalCommand *pPTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a VT motion command.",
        "input": "",
        "output": "StartVT (VTCommand *pVTCommand, unsigned int numAddlCommands=0, VTAdditionalCommand *pVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered VT motion command.",
        "input": "",
        "output": "StartVT (VTCommand *pVTCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, VTAdditionalCommand *pVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered VT motion command with multiple trigger events. ",
        "input": "",
        "output": "StartVT (VTCommand *pVTCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, VTAdditionalCommand *pVTAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a AT motion command. ",
        "input": "",
        "output": "StartAT (ATCommand *pATCommand, unsigned int numAddlCommands=0, ATAdditionalCommand *pATAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered AT motion command.",
        "input": "",
        "output": "StartAT (ATCommand *pATCommand, Trigger *pTrigger, unsigned int numAddlCommands=0, ATAdditionalCommand *pATAddlCommand=NULL)"
    },
    {
        "instruction": "Start executing a triggered AT motion command with multiple trigger events. ",
        "input": "",
        "output": "StartAT (ATCommand *pATCommand, TriggerEvents *pTriggerEvents, unsigned int numAddlCommands=0, ATAdditionalCommand *pATAddlCommand=NULL)"
    },
    {
        "instruction": "This class contains sync functions. ",
        "input": "",
        "output": "Sync (CoreMotion *f)"
    },
    {
        "instruction": "This class contains options for combine sync control.",
        "input": "",
        "output": "SyncCombineOptions"
    },
    {
        "instruction": "This class contains settings for a sync group. ",
        "input": "",
        "output": "SyncGroup"
    },
    {
        "instruction": "This enumerator class enumerates startup types for a sync group.",
        "input": "",
        "output": "SyncGroupStartupType"
    },
    {
        "instruction": "This class contains the current status of a sync group channel.",
        "input": "",
        "output": "SyncGroupStatus"
    },
    {
        "instruction": "This class contains options for sync control.",
        "input": "",
        "output": "SyncOptions"
    },
    {
        "instruction": "Establish synchronous control between a master axis and a slave axis.",
        "input": "",
        "output": "SetSyncMasterSlave (int masterAxis, int slaveAxis, SyncOptions *pSyncOptions=NULL)"
    },
    {
        "instruction": "Combine the position commands of two master axes and set it as the position command of a slave axis.",
        "input": "",
        "output": "SetSyncCombine (int masterAxis1, int masterAxis2, int slaveAxis, SyncCombineOptions *pSyncCombineOptions=NULL)"
    },
    {
        "instruction": "Set the absolute sync phase of a slave axis.",
        "input": "",
        "output": "SetAbsoluteSyncPhase (int slaveAxis, double phase, Profile *pProfile)"
    },
    {
        "instruction": "Add a relative sync phase to a slave axis. ",
        "input": "",
        "output": "AddRelativeSyncPhase (int slaveAxis, double phase, Profile *pProfile)"
    },
    {
        "instruction": "Set the sync gear ratio between a sync slave axis and the master axis. ",
        "input": "",
        "output": "SetSyncGearRatio (int slaveAxis, double gearRatio, Profile *pProfile)"
    },
    {
        "instruction": "Establish sync control between two axes, and set the sync gear ratio between a sync slave axis and the master axis.",
        "input": "",
        "output": "SetSyncGearRatio (int masterAxis, int slaveAxis, double gearRatio, Profile *pProfile)"
    },
    {
        "instruction": "Resolve sync control for a slave axis, and immediately start a jog command for the slave axis. ",
        "input": "",
        "output": "SyncToJog (int slaveAxis, Profile *pProfile)"
    },
    {
        "instruction": "Resolve sync control for a slave axis, and immediately start a jog command for the slave axis with the velocity equal to the velocity that the slave axis was moving at",
        "input": "",
        "output": "SyncToJog (int slaveAxis)"
    },
    {
        "instruction": "Release the specified slave axis from synchronous control.",
        "input": "",
        "output": "ResolveSync (int slaveAxis)"
    },
    {
        "instruction": "Set the axes and parameters of a synchronization group.",
        "input": "",
        "output": "SetSyncGroup (int groupId, SyncGroup syncGroup)"
    },
    {
        "instruction": "Get the axes and parameters of a sync group. ",
        "input": "",
        "output": "GetSyncGroup (int groupId, SyncGroup *pSyncGroup)"
    },
    {
        "instruction": "Add another axis to an existing sync group. ",
        "input": "",
        "output": "AddAxisToSyncGroup (int groupId, int axis, unsigned char isMaster)"
    },
    {
        "instruction": "Remove an axis from an existing sync group. ",
        "input": "",
        "output": "RemoveAxisFromSyncGroup (int groupId, int axis)"
    },
    {
        "instruction": "Enable or disable a sync group. ",
        "input": "",
        "output": "EnableSyncGroup (int groupId, unsigned char enable)"
    },
    {
        "instruction": "Read the current status of the specified sync group.",
        "input": "",
        "output": "GetSyncGroupStatus (int groupId, SyncGroupStatus *pStatus)"
    },
    {
        "instruction": "Clear all sync group errors of the specified sync group. ",
        "input": "",
        "output": "ClearSyncGroupError (int groupId)"
    },
    {
        "instruction": "This class contains velocity command functions. ",
        "input": "",
        "output": "Velocity (CoreMotion *f)"
    },
    {
        "instruction": "This class contains data for a time-based command. ",
        "input": "",
        "output": "TimeCommand"
    },
    {
        "instruction": "This class contains data for a timed velocity command. ",
        "input": "",
        "output": "TimedVelCommand"
    },
    {
        "instruction": "This class contains data for a triggered timed velocity command.",
        "input": "",
        "output": "TriggerTimedVelCommand"
    },
    {
        "instruction": "This class contains data for a triggered velocity command.",
        "input": "",
        "output": "TriggerVelCommand"
    },
    {
        "instruction": "This class contains data for a velocity command. ",
        "input": "",
        "output": "VelCommand"
    },
    {
        "instruction": "Start a velocity command.",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand)"
    },
    {
        "instruction": "Start a timed velocity command. ",
        "input": "",
        "output": "StartVel (TimedVelCommand *pTimedVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command. ",
        "input": "",
        "output": "StartVel (TriggerVelCommand *pVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command with multiple trigger events.",
        "input": "",
        "output": "StartVel (TriggerTimedVelCommand *pTimedVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command with multiple trigger events.",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered timed velocity command with multiple trigger events",
        "input": "",
        "output": "StartVel (TimedVelCommand *pTimedVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a velocity command and set the maximum torque limit.",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand, double maxTrqLimit)"
    },
    {
        "instruction": "Start a timed velocity command and set the maximum torque limit. ",
        "input": "",
        "output": "StartVel (TimedVelCommand *pTimedVelCommand, double maxTrqLimit)"
    },
    {
        "instruction": "Start a triggered velocity command and set the maximum torque limit.",
        "input": "",
        "output": "StartVel (TriggerVelCommand *pVelCommand, double maxTrqLimit)"
    },
    {
        "instruction": "Start a triggered timed velocity command and set the maximum torque limit.",
        "input": "",
        "output": "StartVel (TriggerTimedVelCommand *pTimedVelCommand, double maxTrqLimit)"
    },
    {
        "instruction": "Start a triggered velocity command with multiple trigger events and set the maximum torque limit.",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand, double maxTrqLimit, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered timed velocity command with multiple trigger events and set the maximum torque limit.",
        "input": "",
        "output": "StartVel (TimedVelCommand *pTimedVelCommand, double maxTrqLimit, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start velocity commands for multiple axes. ",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand)"
    },
    {
        "instruction": "Start timed velocity commands for multiple axes",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TimedVelCommand *pTimedVelCommand)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TriggerVelCommand *pVelCommand)"
    },
    {
        "instruction": "Start triggered timed velocity commands for multiple axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TriggerTimedVelCommand *pTimedVelCommand)"
    },
    {
        "instruction": "Start triggered velocity commands with multiple trigger events for multiple axes. ",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered timed velocity commands with multiple trigger events for multiple axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TimedVelCommand *pTimedVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start velocity commands for multiple axes and set the maximum torque limits of the commanded axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand, double *pMaxTrqLimit)"
    },
    {
        "instruction": "Start timed velocity commands for multiple axes and set the maximum torque limits of the commanded axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TimedVelCommand *pTimedVelCommand, double *pMaxTrqLimit)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes and set the maximum torque limits of the commanded axes",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TriggerVelCommand *pVelCommand, double *pMaxTrqLimit)"
    },
    {
        "instruction": "Start triggered timed velocity commands for multiple axes and set the maximum torque limits of the commanded axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TriggerTimedVelCommand *pTimedVelCommand, double *pMaxTrqLimit)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes with multiple trigger events and set the maximum torque limits of the commanded axes",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand, double *pMaxTrqLimit, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered timed velocity commands for multiple axes with multiple trigger events and set the maximum torque limits of the commanded axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, TimedVelCommand *pTimedVelCommand, double *pMaxTrqLimit, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Stop the motion of an axis executing a velocity command",
        "input": "",
        "output": "Stop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes executing velocity commands. ",
        "input": "",
        "output": "Stop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop the motion of an axis executing a velocity command using the quick stop deceleration system parameter.",
        "input": "",
        "output": "ExecQuickStop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes executing velocity commands using the quick stop deceleration system parameter",
        "input": "",
        "output": "ExecQuickStop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop an axis that is currently in motion in the specified amount of time using a trapezoidal profile. ",
        "input": "",
        "output": "ExecTimedStop (int axis, double timeMilliseconds)"
    },
    {
        "instruction": "Stop multiple axes that are currently in motion in the specified amount of time using a trapezoidal profile. ",
        "input": "",
        "output": "ExecTimedStop (AxisSelection *pAxisSelection, double timeMilliseconds)"
    },
    {
        "instruction": "Stop multiple axes that are currently in motion in the specified amounts of time using a trapezoidal profile.",
        "input": "",
        "output": "ExecTimedStop (unsigned int numCommands, TimeCommand *pTimeCommand)"
    },
    {
        "instruction": "Set the maximum motor speed of an axis.",
        "input": "",
        "output": "SetMaxMotorSpeed (int axis, double speed)"
    },
    {
        "instruction": "Get the maximum motor speed of an axis.",
        "input": "",
        "output": "GetMaxMotorSpeed (int axis, double *pSpeed)"
    },
    {
        "instruction": "Set an override velocity for a single axis that is currently executing a velocity command.",
        "input": "",
        "output": "OverrideVel (VelCommand *pVelCommand)"
    },
    {
        "instruction": "Set override velocities for multiple axes that are currently executing velocity commands.",
        "input": "",
        "output": "OverrideVel (unsigned int numCommands, VelCommand *pVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command for an axis that is currently executing a position command.",
        "input": "",
        "output": "StartPosToVel (TriggerVelCommand *pTriggerVelCommand)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes that are currently executing position commands.",
        "input": "",
        "output": "StartPosToVel (unsigned int numCommands, TriggerVelCommand *pTriggerVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events.",
        "input": "",
        "output": "StartPosToVel (VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events",
        "input": "",
        "output": "StartPosToVel (unsigned int numCommands, VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered velocity command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "input": "",
        "output": "StartTrqToVel (TriggerVelCommand *pTriggerVelCommand)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToVel (unsigned int numCommands, TriggerVelCommand *pTriggerVelCommand)"
    },
    {
        "instruction": "Start a triggered velocity command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "input": "",
        "output": "StartTrqToVel (VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered velocity commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartTrqToVel (unsigned int numCommands, VelCommand *pVelCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "This class contains torque command functions. ",
        "input": "",
        "output": "Torque (CoreMotion *f)"
    },
    {
        "instruction": "This class contains data for a ramp rate torque command.",
        "input": "",
        "output": "RampRateTrqCommand"
    },
    {
        "instruction": "This class contains data for a ramp time torque command. ",
        "input": "",
        "output": "RampTimeTrqCommand"
    },
    {
        "instruction": "This class contains data for a triggered ramp rate torque command.",
        "input": "",
        "output": "TriggerRampRateTrqCommand"
    },
    {
        "instruction": "This class contains data for a triggered ramp rate torque command.",
        "input": "",
        "output": "TriggerRampTimeTrqCommand"
    },
    {
        "instruction": "This class contains data for a triggered torque command. ",
        "input": "",
        "output": "TriggerTrqCommand"
    },
    {
        "instruction": "This class contains data for a torque command.",
        "input": "",
        "output": "TrqCommand"
    },
    {
        "instruction": "Set the maximum torque limit of an axis.",
        "input": "",
        "output": "SetMaxTrqLimit (int axis, double torque)"
    },
    {
        "instruction": "Get the maximum torque limit of an axis.",
        "input": "",
        "output": "GetMaxTrqLimit (int axis, double *pTorque)"
    },
    {
        "instruction": "Set the maximum torque limit in the positive direction of an axis.",
        "input": "",
        "output": "SetPositiveTrqLimit (int axis, double torque)"
    },
    {
        "instruction": "Get the maximum torque limit in the positive direction of an axis.",
        "input": "",
        "output": "GetPositiveTrqLimit (int axis, double *pTorque)"
    },
    {
        "instruction": "Set the maximum torque limit in the negative direction of an axis. ",
        "input": "",
        "output": "SetNegativeTrqLimit (int axis, double torque)"
    },
    {
        "instruction": "Get the maximum torque limit in the negative direction of an axis. ",
        "input": "",
        "output": "GetNegativeTrqLimit (int axis, double *pTorque)"
    },
    {
        "instruction": "Start a torque command.",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command.",
        "input": "",
        "output": "StartTrq (TriggerTrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events. ",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands for multiple axes. ",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TriggerTrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events for multiple axes. ",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a torque command and set the maximum motor speed. ",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command and set the maximum motor speed.",
        "input": "",
        "output": "StartTrq (TriggerTrqCommand *pTrqCommand, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events and set the maximum motor speed. ",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand, double maxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands for multiple axes and set the maximum motor speeds of the commanded axes.",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes and set the maximum motor speeds of the commanded axes.",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TriggerTrqCommand *pTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand, double *pMaxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time",
        "input": "",
        "output": "StartRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time. ",
        "input": "",
        "output": "StartRampTimeTrq (TriggerTrqCommand *pTrqCommand, unsigned int rampCycleTime)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events in which the torque is changed over time.",
        "input": "",
        "output": "StartRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands in which the torque is changed over time for multiple axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, TriggerRampTimeTrqCommand *pRampTimeTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events in which the torque is changed over time for multiple axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a torque command in which the torque is changed over time and set the maximum motor speed.",
        "input": "",
        "output": "StartRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time and set the maximum motor speed.",
        "input": "",
        "output": "StartRampTimeTrq (TriggerTrqCommand *pTrqCommand, unsigned int rampCycleTime, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events in which the torque is changed over time and set the maximum motor speed.",
        "input": "",
        "output": "StartRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, double maxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands in which the torque is changed over time for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, TriggerRampTimeTrqCommand *pRampTimeTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events in which the torque is changed over time for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand, double *pMaxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a torque command in which the torque is changed at a specified rate. ",
        "input": "",
        "output": "StartRampRateTrq (TrqCommand *pTrqCommand, double rampRate)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate.",
        "input": "",
        "output": "StartRampRateTrq (TriggerTrqCommand *pTrqCommand, double rampRate)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events in which the torque is changed at a specified rate. ",
        "input": "",
        "output": "StartRampRateTrq (TrqCommand *pTrqCommand, double rampRate, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands in which the torque is changed at a specified rate for multiple axes. ",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes.",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, TriggerRampRateTrqCommand *pRampRateTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events in which the torque is changed at a specified rate for multiple axes. ",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a torque command in which the torque is changed at a specified rate and set the maximum motor speed. ",
        "input": "",
        "output": "StartRampRateTrq (TrqCommand *pTrqCommand, double rampRate, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate and set the maximum motor speed.",
        "input": "",
        "output": "StartRampRateTrq (TriggerTrqCommand *pTrqCommand, double rampRate, double maxMotorSpeed)"
    },
    {
        "instruction": "Start a triggered torque command with multiple trigger events in which the torque is changed at a specified rate and set the maximum motor speed. ",
        "input": "",
        "output": "StartRampRateTrq (TrqCommand *pTrqCommand, double rampRate, double maxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start torque commands in which the torque is changed at a specified rate for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes and set the maximum motor speeds of the commanded axes. ",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, TriggerRampRateTrqCommand *pRampRateTrqCommand, double *pMaxMotorSpeed)"
    },
    {
        "instruction": "Start triggered torque commands with multiple trigger events in which the torque is changed at a specified rate for multiple axes and set the maximum motor speeds of the commanded axes.",
        "input": "",
        "output": "StartRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand, double *pMaxMotorSpeed, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Stop a torque command. ",
        "input": "",
        "output": "StopTrq (int axis)"
    },
    {
        "instruction": "Stop torque commands for multiple axes. ",
        "input": "",
        "output": "StopTrq (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Start a triggered torque command for an axis that is currently executing a position command.",
        "input": "",
        "output": "StartPosToTrq (TriggerTrqCommand *pTriggerTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes that are currently executing position commands.",
        "input": "",
        "output": "StartPosToTrq (unsigned int numCommands, TriggerTrqCommand *pTriggerTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events. ",
        "input": "",
        "output": "StartPosToTrq (TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events.",
        "input": "",
        "output": "StartPosToTrq (unsigned int numCommands, TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time for an axis that is currently executing a position command. ",
        "input": "",
        "output": "StartPosToRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, Trigger *pTrigger)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes that are currently executing position commands. ",
        "input": "",
        "output": "StartPosToRampTimeTrq (unsigned int numCommands, TriggerRampTimeTrqCommand *pTriggerRampTimeTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time for an axis that is currently executing a position command. ",
        "input": "",
        "output": "StartPosToRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartPosToRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate for an axis that is currently executing a position command. ",
        "input": "",
        "output": "StartPosToRampRateTrq (TrqCommand *pTrqCommand, double rampRate, Trigger *pTrigger)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes that are currently executing position commands.",
        "input": "",
        "output": "StartPosToRampRateTrq (unsigned int numCommands, TriggerRampRateTrqCommand *pTriggerRampRateTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate for an axis that is currently executing a position command. ",
        "input": "",
        "output": "StartPosToRampRateTrq (TrqCommand *pTrqCommand, double rampRate, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events",
        "input": "",
        "output": "StartPosToRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command for an axis that is currently executing a velocity command.",
        "input": "",
        "output": "StartVelToTrq (TriggerTrqCommand *pTriggerTrqCommand)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes that are currently executing velocity commands.",
        "input": "",
        "output": "StartVelToTrq (unsigned int numCommands, TriggerTrqCommand *pTriggerTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events.",
        "input": "",
        "output": "StartVelToTrq (TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "input": "",
        "output": "StartVelToTrq (unsigned int numCommands, TrqCommand *pTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time for an axis that is currently executing a velocity command. ",
        "input": "",
        "output": "StartVelToRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, Trigger *pTrigger)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes that are currently executing velocity commands.",
        "input": "",
        "output": "StartVelToRampTimeTrq (unsigned int numCommands, TriggerRampTimeTrqCommand *pTriggerRampTimeTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed over time for an axis that is currently executing a velocity command. ",
        "input": "",
        "output": "StartVelToRampTimeTrq (TrqCommand *pTrqCommand, unsigned int rampCycleTime, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed over time for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartVelToRampTimeTrq (unsigned int numCommands, RampTimeTrqCommand *pRampTimeTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate for an axis that is currently executing a velocity command. ",
        "input": "",
        "output": "StartVelToRampRateTrq (TrqCommand *pTrqCommand, double rampRate, Trigger *pTrigger)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes that are currently executing velocity commands.",
        "input": "",
        "output": "StartVelToRampRateTrq (unsigned int numCommands, TriggerRampRateTrqCommand *pTriggerRampRateTrqCommand)"
    },
    {
        "instruction": "Start a triggered torque command in which the torque is changed at a specified rate for an axis that is currently executing a velocity command. ",
        "input": "",
        "output": "StartVelToRampRateTrq (TrqCommand *pTrqCommand, double rampRate, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Start triggered torque commands in which the torque is changed at a specified rate for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events. ",
        "input": "",
        "output": "StartVelToRampRateTrq (unsigned int numCommands, RampRateTrqCommand *pRampRateTrqCommand, TriggerEvents *pTriggerEvents)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "UserMemory (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "UserMemory (const UserMemory &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "UserMemory & operator= (const UserMemory &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "UserMemory ()"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~UserMemory ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Set the value of a user memory bit.",
        "input": "",
        "output": "SetMBit (unsigned int addr, unsigned int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of a user memory byte.",
        "input": "",
        "output": "SetMByte (unsigned int addr, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple user memory bytes. ",
        "input": "",
        "output": "SetMBytes (unsigned int addr, unsigned int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple user memory bits. ",
        "input": "",
        "output": "SetMBits (unsigned int *pAddr, unsigned int *pBit, unsigned char *pData, unsigned int count)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "SetMAnalogDataChar (int addr, char analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "SetMAnalogDataUChar (int addr, unsigned char analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "SetMAnalogDataShort (int addr, short analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "SetMAnalogDataUShort (int addr, unsigned short analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "SetMAnalogDataInt (int addr, int analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "SetMAnalogDataUInt (int addr, unsigned int analogData)"
    },
    {
        "instruction": "Get the value of a user memory bit.",
        "input": "",
        "output": "GetMBit (unsigned int addr, unsigned int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of a user memory byte.",
        "input": "",
        "output": "GetMByte (unsigned int addr, unsigned char *pData) "
    },
    {
        "instruction": "Get the value of multiple user memory bytes.",
        "input": "",
        "output": "GetMBytes (unsigned int addr, unsigned int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "GetMAnalogDataChar (unsigned int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "GetMAnalogDataUChar (unsigned int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "GetMAnalogDataShort (unsigned int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "GetMAnalogDataUShort (unsigned int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "GetMAnalogDataInt (unsigned int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "GetMAnalogDataUInt (unsigned int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Set the value of a user memory bit.",
        "input": "",
        "output": "SetMBitEx (unsigned int addr, unsigned int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of a user memory byte.",
        "input": "",
        "output": "SetMByteEx (unsigned int addr, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple user memory bytes. ",
        "input": "",
        "output": "SetMBytesEx (unsigned int addr, unsigned int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple user memory bits. ",
        "input": "",
        "output": "SetMBitsEx (unsigned int *pAddr, unsigned int *pBit, unsigned char *pData, unsigned int count)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "SetMAnalogDataCharEx (int addr, char analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "SetMAnalogDataUCharEx (int addr, unsigned char analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "SetMAnalogDataShortEx (int addr, short analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "SetMAnalogDataUShortEx (int addr, unsigned short analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "SetMAnalogDataIntEx (int addr, int analogData)"
    },
    {
        "instruction": "Set the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "SetMAnalogDataUIntEx (int addr, unsigned int analogData)"
    },
    {
        "instruction": "Get the value of a user memory bit.",
        "input": "",
        "output": "GetMBitEx (unsigned int addr, unsigned int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of a user memory byte.",
        "input": "",
        "output": "GetMByteEx (unsigned int addr, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple user memory bytes. ",
        "input": "",
        "output": "GetMBytesEx (unsigned int addr, unsigned int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "GetMAnalogDataCharEx (unsigned int addr, char *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning one byte.",
        "input": "",
        "output": "GetMAnalogDataUCharEx (unsigned int addr, unsigned char *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "GetMAnalogDataShortEx (unsigned int addr, short *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning two bytes.",
        "input": "",
        "output": "GetMAnalogDataUShortEx (unsigned int addr, unsigned short *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "GetMAnalogDataIntEx (unsigned int addr, int *pAnalogData)"
    },
    {
        "instruction": "Get the value of user memory analog data spanning four bytes.",
        "input": "",
        "output": "GetMAnalogDataUIntEx (unsigned int addr, unsigned int *pAnalogData)"
    },
    {
        "instruction": "Get a pointer to the memory address of the user memory address space.",
        "input": "",
        "output": "GetUserMemoryAddress (void **pptr)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "This class contains Simu API functions. ",
        "input": "",
        "output": "Simu"
    },
    {
        "instruction": "This class describes the simulator axis data. ",
        "input": "",
        "output": "SimuAxisData"
    },
    {
        "instruction": "This class describes the simulator axis signal. ",
        "input": "",
        "output": "SimuAxisSignal"
    },
    {
        "instruction": "This enumerator class enumerates the simulator axis states.",
        "input": "",
        "output": "SimuAxisState"
    },
    {
        "instruction": "This enumerator class enumerates the Simu library error codes.",
        "input": "",
        "output": "SimuErrorCode"
    },
    {
        "instruction": "This class describes the simulator IO data.",
        "input": "",
        "output": "SimuIoData"
    },
    {
        "instruction": "This class describes the simulator master information.",
        "input": "",
        "output": "SimuMasterInfo"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "Simu (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class. ",
        "input": "",
        "output": "Simu (const Simu &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Simu & operator= (const Simu &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "Simu ()"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device of the specified device type.",
        "input": "",
        "output": "Simu (DeviceType::T type)"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~Simu ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Set the value of a simulator input bit.",
        "input": "",
        "output": "SetInBit (int byte, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of a simulator input byte.",
        "input": "",
        "output": "SetInByte (int byte, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple simulator input bytes. ",
        "input": "",
        "output": "SetInBytes (int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple simulator input bits. ",
        "input": "",
        "output": "SetInBits (int *pByte, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Clear the set value of a simulator input bit.",
        "input": "",
        "output": "ClearInBit (int byte, int bit)"
    },
    {
        "instruction": "Clear the set value of a simulator input byte. ",
        "input": "",
        "output": "ClearInByte (int byte)"
    },
    {
        "instruction": "Clear the set value of multiple simulator input bytes.",
        "input": "",
        "output": "ClearInBytes (int byte, int size)"
    },
    {
        "instruction": "Clear the set value of multiple simulator input bits.",
        "input": "",
        "output": "ClearInBits (int *pByte, int *pBit, int count)"
    },
    {
        "instruction": "Set the value of the \"servo on feedback\" signal of a simulator axis.",
        "input": "",
        "output": "SetServoOnFeedback (int axis, int newStatus)"
    },
    {
        "instruction": "Set the alarm state of a simulator axis.",
        "input": "",
        "output": "SetAlarm (int axis, int alarmCode)"
    },
    {
        "instruction": "Set the warning state of a simulator axis. ",
        "input": "",
        "output": "SetWarning (int axis, int warningCode)"
    },
    {
        "instruction": "Set the home switch state of a simulator axis. ",
        "input": "",
        "output": "SetHomeSwitch (int axis, int newStatus)"
    },
    {
        "instruction": "Set the negative limit switch state of a simulator axis.",
        "input": "",
        "output": "SetLimitSwitchNegative (int axis, int newStatus)"
    },
    {
        "instruction": "Set the positive limit switch state of a simulator axis.",
        "input": "",
        "output": "SetLimitSwitchPositive (int axis, int newStatus)"
    },
    {
        "instruction": "Set the \"ZPulse 0 detected\" signal and the latched ZPulse position feedback of a simulator axis.",
        "input": "",
        "output": "SetZPulse0Detected (int axis, int latchedZPulseFeedback)"
    },
    {
        "instruction": "Set the \"ZPulse 1 detected\" signal and the latched ZPulse position feedback of a simulator axis.",
        "input": "",
        "output": "SetZPulse1Detected (int axis, int latchedZPulseFeedback)"
    },
    {
        "instruction": "Set the \"touch probe 0 detected\" signal and the latched touch probe 0 position feedback of a simulator axis.",
        "input": "",
        "output": "SetTouchProbe0Detected (int axis, int touchProbeDetectedFeedback)"
    },
    {
        "instruction": "Set the \"touch probe 1 detected\" signal and the latched touch probe 1 position feedback of a simulator axis.",
        "input": "",
        "output": "SetTouchProbe1Detected (int axis, int touchProbeDetectedFeedback)"
    },
    {
        "instruction": "Clear the set \"servo on feedback\" signal for a simulator axis.",
        "input": "",
        "output": "ClearServoOnFeedback (int axis)"
    },
    {
        "instruction": "Clear the set alarm state for a simulator axis. ",
        "input": "",
        "output": "ClearAlarm (int axis)"
    },
    {
        "instruction": "Clear the set warning state for a simulator axis. ",
        "input": "",
        "output": "ClearWarning (int axis)"
    },
    {
        "instruction": "Clear the set home switch state for a simulator axis.",
        "input": "",
        "output": "ClearHomeSwitch (int axis)"
    },
    {
        "instruction": "Clear the set negative limit switch state for a simulator axis.",
        "input": "",
        "output": "ClearLimitSwitchNegative (int axis)"
    },
    {
        "instruction": "Clear the set positive limit switch state for a simulator axis.",
        "input": "",
        "output": "ClearLimitSwitchPositive (int axis)"
    },
    {
        "instruction": "Clear the set \"ZPulse 0 detected\" signal for a simulator axis.",
        "input": "",
        "output": "ClearZPulse0Detected (int axis)"
    },
    {
        "instruction": "Clear the set \"ZPulse 1 detected\" signal for a simulator axis.",
        "input": "",
        "output": "ClearZPulse1Detected (int axis)"
    },
    {
        "instruction": "Clear the set \"touch probe 0 detected signal\" for a simulator axis.",
        "input": "",
        "output": "ClearTouchProbe0Detected (int axis)"
    },
    {
        "instruction": "Clear the set \"touch probe 1 detected signal\" for a simulator axis.",
        "input": "",
        "output": "ClearTouchProbe1Detected (int axis)"
    },
    {
        "instruction": "Set the master info update period.",
        "input": "",
        "output": "SetUpdatePeriod (unsigned int period)"
    },
    {
        "instruction": "Read the current master information from the engine.",
        "input": "",
        "output": "Set the master info update period."
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the library version information of current using SimuApi.lib.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the Ecat object passed to this constructor is used to execute API functions.",
        "input": "",
        "output": "Ecat (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Ecat (const Ecat &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class.",
        "input": "",
        "output": "Ecat & operator= (const Ecat &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device.",
        "input": "",
        "output": "Ecat ()"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device of the specified device type.",
        "input": "",
        "output": "Ecat (DeviceType::T type)"
    },
    {
        "instruction": "Destructor for this class.",
        "input": "",
        "output": "~Ecat ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll.",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Scan the network topology.",
        "input": "",
        "output": "ScanNetwork ()"
    },
    {
        "instruction": "Scan the network topology.",
        "input": "",
        "output": "ScanNetwork (int masterId)"
    },
    {
        "instruction": "Change the specified slave state.",
        "input": "",
        "output": "ChangeSlaveState (int slaveId, EcStateMachine::T state, int *errorCode)"
    },
    {
        "instruction": "Change the specified slave state.",
        "input": "",
        "output": "ChangeSlaveState (int masterId, int slaveId, EcStateMachine::T state, int *errorCode)"
    },
    {
        "instruction": "Start hot connect. ",
        "input": "",
        "output": "StartHotconnect ()"
    },
    {
        "instruction": "Start hot connect.",
        "input": "",
        "output": "StartHotconnect (int masterId)"
    },
    {
        "instruction": "Reset the reference clock information.",
        "input": "",
        "output": "ResetRefClockInfo ()"
    },
    {
        "instruction": "Reset the reference clock information.",
        "input": "",
        "output": "ResetRefClockInfo (int masterId)"
    },
    {
        "instruction": "Reset the transmission statistics information. ",
        "input": "",
        "output": "ResetTransmitStatisticsInfo ()"
    },
    {
        "instruction": "Reset the transmission statistics information.",
        "input": "",
        "output": "ResetTransmitStatisticsInfo (int masterId)"
    },
    {
        "instruction": "Set the master info update period. ",
        "input": "",
        "output": "SetUpdatePeriod (unsigned int period)"
    },
    {
        "instruction": "Read the current master information from the engine.",
        "input": "",
        "output": "GetMasterInfo (EcMasterInfo *master)"
    },
    {
        "instruction": "Read the specified master information from the engine.",
        "input": "",
        "output": "GetMasterInfo (int masterId, EcMasterInfo *master)"
    },
    {
        "instruction": "Read the master list information from the engine.",
        "input": "",
        "output": "GetMasterInfoList (EcMasterInfoList *masters)"
    },
    {
        "instruction": "Get the ENI file path for specified slave.",
        "input": "",
        "output": "GetEniFilePath (int slaveId, char *path, int len)"
    },
    {
        "instruction": "Get the ENI file path for specified slave. ",
        "input": "",
        "output": "GetEniFilePath (int slaveId, wchar_t *path, int len)"
    },
    {
        "instruction": "Get the ENI file path for specified slave. ",
        "input": "",
        "output": "GetEniFilePath (int masterId, int slaveId, char *path, int len)"
    },
    {
        "instruction": "Get the ENI file path for specified slave.",
        "input": "",
        "output": "GetEniFilePath (int masterId, int slaveId, wchar_t *path, int len)"
    },
    {
        "instruction": "Set the ENI file path for specified slave.",
        "input": "",
        "output": "SetEniFilePath (int slaveId, char *path, unsigned char oneshot=1)"
    },
    {
        "instruction": "Set the ENI file path for specified slave.",
        "input": "",
        "output": "SetEniFilePath (int slaveId, wchar_t *path, unsigned char oneshot=1)"
    },
    {
        "instruction": "Set the ENI file path for specified slave.",
        "input": "",
        "output": "SetEniFilePath (int masterId, int slaveId, char *path, unsigned char oneshot=1)"
    },
    {
        "instruction": "Set the ENI file path for specified slave.",
        "input": "",
        "output": "SetEniFilePath (int masterId, int slaveId, wchar_t *path, unsigned char oneshot=1)"
    },
    {
        "instruction": "Write data to the specified slave register address. ",
        "input": "",
        "output": "RegisterWrite (int slaveId, int regAddr, int len, unsigned char *data)"
    },
    {
        "instruction": "Write data to the specified slave register address.",
        "input": "",
        "output": "RegisterWrite (int masterId, int slaveId, int regAddr, int len, unsigned char *data)"
    },
    {
        "instruction": "Read data from the specified slave register address.",
        "input": "",
        "output": "RegisterRead (int slaveId, int regAddr, int len, unsigned char *buff)"
    },
    {
        "instruction": "Read data from the specified slave register address.",
        "input": "",
        "output": "RegisterRead (int masterId, int slaveId, int regAddr, int len, unsigned char *buff)"
    },
    {
        "instruction": "Write data to the specified slave register address. ",
        "input": "",
        "output": "RegisterWrite (int slaveId, int regAddr, int len, unsigned char *data, EcRegisterWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write data to the specified slave register address.",
        "input": "",
        "output": "RegisterWrite (int masterId, int slaveId, int regAddr, int len, unsigned char *data, EcRegisterWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read data from the specified slave register address.",
        "input": "",
        "output": "RegisterRead (int slaveId, int regAddr, int len, EcRegisterReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read data from the specified slave register address.",
        "input": "",
        "output": "RegisterRead (int masterId, int slaveId, int regAddr, int len, EcRegisterReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Broadcast write data to all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastWrite (int regAddr, int len, unsigned char *data, unsigned short *wkc)"
    },
    {
        "instruction": "Broadcast write data to all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastWrite (int masterId, int regAddr, int len, unsigned char *data, unsigned short *wkc)"
    },
    {
        "instruction": "Broadcast read data from all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastRead (int regAddr, int len, unsigned char *buff, unsigned short *wkc)"
    },
    {
        "instruction": "Broadcast read data from all slaves' register addresses. ",
        "input": "",
        "output": "RegisterBroadcastRead (int masterId, int regAddr, int len, unsigned char *buff, unsigned short *wkc)"
    },
    {
        "instruction": "Broadcast write data to all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastWrite (int regAddr, int len, unsigned char *data, EcRegisterBroadcastWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Broadcast write data to all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastWrite (int masterId, int regAddr, int len, unsigned char *data, EcRegisterBroadcastWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Broadcast read data from all slaves' register addresses.",
        "input": "",
        "output": "RegisterBroadcastRead (int masterId, int regAddr, int len, EcRegisterBroadcastReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int slaveId, int index, int subindex, int sdoDataSize, unsigned char *sdoData, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int masterId, int slaveId, int index, int subindex, int sdoDataSize, unsigned char *sdoData, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Upload data from the specified slave SDO. ",
        "input": "",
        "output": "SdoUpload (int slaveId, int index, int subindex, int sdoBuffSize, unsigned char *sdoBuff, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Upload data from the specified slave SDO. ",
        "input": "",
        "output": "SdoUpload (int masterId, int slaveId, int index, int subindex, int sdoBuffSize, unsigned char *sdoBuff, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int slaveId, int index, int subindex, int sdoDataSize, unsigned char *sdoData, EcSdoDownloadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Download data to the specified slave SDO. ",
        "input": "",
        "output": "SdoDownload (int masterId, int slaveId, int index, int subindex, int sdoDataSize, unsigned char *sdoData, EcSdoDownloadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int slaveId, int index, int subindex, EcSdoUploadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int masterId, int slaveId, int index, int subindex, EcSdoUploadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoDataSize, unsigned char *sdoData, unsigned int *errCode, unsigned int waitTime=0, BOOL complete=FALSE)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int masterId, int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoDataSize, unsigned char *sdoData, unsigned int *errCode, unsigned int waitTime=0, BOOL complete=FALSE)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoBuffSize, unsigned char *sdoBuff, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0, BOOL complete=FALSE)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int masterId, int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoBuffSize, unsigned char *sdoBuff, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0, BOOL complete=FALSE)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoDataSize, unsigned char *sdoData, EcSdoDownloadCallBack callbackFunc, unsigned int waitTime, BOOL complete=FALSE)"
    },
    {
        "instruction": "Download data to the specified slave SDO.",
        "input": "",
        "output": "SdoDownload (int masterId, int slaveId, int index, int subindex, EcSdoType::T sdoType, int sdoDataSize, unsigned char *sdoData, EcSdoDownloadCallBack callbackFunc, unsigned int waitTime, BOOL complete=FALSE)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int slaveId, int index, int subindex, EcSdoType::T sdoType, EcSdoUploadCallBack callbackFunc, unsigned int waitTime, BOOL complete=FALSE)"
    },
    {
        "instruction": "Upload data from the specified slave SDO.",
        "input": "",
        "output": "SdoUpload (int masterId, int slaveId, int index, int subindex, EcSdoType::T sdoType, EcSdoUploadCallBack callbackFunc, unsigned int waitTime, BOOL complete=FALSE)"
    },
    {
        "instruction": "Get the OD list from the specified slave.",
        "input": "",
        "output": "GetSdoInfoODList (int slaveId, EcObjectDescriptionListType::T type, EcSlaveSdoInfoObjectDescriptionList *list)"
    },
    {
        "instruction": "Get the OD list from the specified slave.",
        "input": "",
        "output": "GetSdoInfoODList (int masterId, int slaveId, EcObjectDescriptionListType::T type, EcSlaveSdoInfoObjectDescriptionList *list)"
    },
    {
        "instruction": "Get the ED list from the specified slave's OD index.",
        "input": "",
        "output": "GetSdoInfoEDList (int slaveId, int index, EcSlaveSdoInfoEntryDescriptionList *list)"
    },
    {
        "instruction": "Get the ED list from the specified slave's OD index. ",
        "input": "",
        "output": "GetSdoInfoEDList (int masterId, int slaveId, int index, EcSlaveSdoInfoEntryDescriptionList *list)"
    },
    {
        "instruction": "Get the OD list from the specified slave. ",
        "input": "",
        "output": "GetSdoInfoODList (int slaveId, EcObjectDescriptionListType::T type, EcSdoInfoGetODListCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Get the OD list from the specified slave.",
        "input": "",
        "output": "GetSdoInfoODList (int masterId, int slaveId, EcObjectDescriptionListType::T type, EcSdoInfoGetODListCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Get the ED list from the specified slave's OD index.",
        "input": "",
        "output": "GetSdoInfoEDList (int slaveId, int index, EcSdoInfoGetEDListCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Get the ED list from the specified slave's OD index. ",
        "input": "",
        "output": "GetSdoInfoEDList (int masterId, int slaveId, int index, EcSdoInfoGetEDListCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write data to the specified slave's Tx PDO. ",
        "input": "",
        "output": "TxPdoWrite (int slaveId, int index, int subindex, int pdoDataSize, unsigned char *pdoData, unsigned int mask=0)"
    },
    {
        "instruction": "Write data to the specified slave's Tx PDO. ",
        "input": "",
        "output": "TxPdoWrite (int masterId, int slaveId, int index, int subindex, int pdoDataSize, unsigned char *pdoData, unsigned int mask=0)"
    },
    {
        "instruction": "Clear the data which is being written to Tx PDO.",
        "input": "",
        "output": "ClearTxPdoWrite (int slaveId, int index, int subindex)"
    },
    {
        "instruction": "Clear the data which is being written to Tx PDO.",
        "input": "",
        "output": "ClearTxPdoWrite (int masterId, int slaveId, int index, int subindex)"
    },
    {
        "instruction": "Read data from the specified slave's Rx or Tx PDO.",
        "input": "",
        "output": "ClearTxPdoWrite (int masterId, int slaveId, int index, int subindex)"
    },
    {
        "instruction": "Read data from the specified slave's Rx or Tx PDO.",
        "input": "",
        "output": "PdoRead (int masterId, int slaveId, int index, int subindex, int pdoBuffSize, unsigned char *pdoBuff, unsigned int *actualSize)"
    },
    {
        "instruction": "Set the value of an output bit for a slave. ",
        "input": "",
        "output": "SetOutputBit (int slaveId, int byte, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of an output bit for a slave. ",
        "input": "",
        "output": "SetOutputBit (int masterId, int slaveId, int byte, int bit, unsigned char data)"
    },
    {
        "instruction": "Set the value of an output byte for a slave.",
        "input": "",
        "output": "SetOutputByte (int slaveId, int byte, unsigned char data)"
    },
    {
        "instruction": "Set the value of an output byte for a slave.",
        "input": "",
        "output": "SetOutputByte (int masterId, int slaveId, int byte, unsigned char data)"
    },
    {
        "instruction": "Set the value of multiple output bytes for a slave.",
        "input": "",
        "output": "SetOutputBytes (int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple output bytes for a slave.",
        "input": "",
        "output": "SetOutputBytes (int masterId, int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Set the value of multiple output bits for a slave. ",
        "input": "",
        "output": "SetOutputBits (int slaveId, int *pByte, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Set the value of multiple output bits for a slave. ",
        "input": "",
        "output": "SetOutputBits (int masterId, int slaveId, int *pByte, int *pBit, unsigned char *pData, int count)"
    },
    {
        "instruction": "Get the value of an input bit from a slave.",
        "input": "",
        "output": "GetInputBit (int slaveId, int byte, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an input bit from a slave.",
        "input": "",
        "output": "GetInputBit (int masterId, int slaveId, int byte, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an input byte from a slave.",
        "input": "",
        "output": "GetInputByte (int slaveId, int byte, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an input byte from a slave.",
        "input": "",
        "output": "GetInputByte (int masterId, int slaveId, int byte, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple input bytes from a slave.",
        "input": "",
        "output": "GetInputBytes (int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple input bytes from a slave.",
        "input": "",
        "output": "GetInputBytes (int masterId, int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output bit from a slave.",
        "input": "",
        "output": "GetOutputBit (int slaveId, int byte, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output bit from a slave.",
        "input": "",
        "output": "GetOutputBit (int masterId, int slaveId, int byte, int bit, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output byte from a slave. ",
        "input": "",
        "output": "GetOutputByte (int slaveId, int byte, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of an output byte from a slave. ",
        "input": "",
        "output": "GetOutputByte (int masterId, int slaveId, int byte, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple output bytes from a slave.",
        "input": "",
        "output": "GetOutputBytes (int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Get the value of multiple output bytes from a slave.",
        "input": "",
        "output": "GetOutputBytes (int masterId, int slaveId, int byte, int size, unsigned char *pData)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int slaveId, wchar_t *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int masterId, int slaveId, wchar_t *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Write FoE data to the specified slave.",
        "input": "",
        "output": "FoEWrite (int slaveId, wchar_t *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Write FoE data to the specified slave.",
        "input": "",
        "output": "FoEWrite (int masterId, int slaveId, wchar_t *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int slaveId, wchar_t *filePath, char *fileName, unsigned int password, EcFoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int masterId, int slaveId, wchar_t *filePath, char *fileName, unsigned int password, EcFoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write FoE data to the specified slave. ",
        "input": "",
        "output": "FoEWrite (int slaveId, wchar_t *filePath, char *fileName, unsigned int password, EcFoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write FoE data to the specified slave.",
        "input": "",
        "output": "FoEWrite (int masterId, int slaveId, wchar_t *filePath, char *fileName, unsigned int password, EcFoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read FoE data from the specified slave",
        "input": "",
        "output": "FoERead (int slaveId, char *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Read FoE data from the specified slave",
        "input": "",
        "output": "FoERead (int masterId, int slaveId, char *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Write FoE data to the specified slave.",
        "input": "",
        "output": "FoEWrite (int slaveId, char *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Write FoE data to the specified slave.",
        "input": "",
        "output": "FoEWrite (int masterId, int slaveId, char *filePath, char *fileName, unsigned int password, unsigned int *errCode)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int slaveId, char *filePath, char *fileName, unsigned int password, EcFoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read FoE data from the specified slave.",
        "input": "",
        "output": "FoERead (int masterId, int slaveId, char *filePath, char *fileName, unsigned int password, EcFoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write FoE data to the specified slave. ",
        "input": "",
        "output": "FoEWrite (int slaveId, char *filePath, char *fileName, unsigned int password, EcFoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write FoE data to the specified slave. ",
        "input": "",
        "output": "FoEWrite (int masterId, int slaveId, char *filePath, char *fileName, unsigned int password, EcFoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write data to the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIWrite (int slaveId, int siiAddr, int len, unsigned char *data, bool checkSum=false)"
    },
    {
        "instruction": "Write data to the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIWrite (int masterId, int slaveId, int siiAddr, int len, unsigned char *data, bool checkSum=false)"
    },
    {
        "instruction": "Read data from the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIRead (int slaveId, int siiAddr, int len, unsigned char *buff)"
    },
    {
        "instruction": "Read data from the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIRead (int masterId, int slaveId, int siiAddr, int len, unsigned char *buff)"
    },
    {
        "instruction": "Write data to the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIWrite (int slaveId, int siiAddr, int len, unsigned char *data, EcSIIWriteCallBack callbackFunc, unsigned int waitTime, bool checkSum=false)"
    },
    {
        "instruction": "Write data to the specified slave's SII EEPROM.",
        "input": "",
        "output": "SIIWrite (int masterId, int slaveId, int siiAddr, int len, unsigned char *data, EcSIIWriteCallBack callbackFunc, unsigned int waitTime, bool checkSum=false)"
    },
    {
        "instruction": "Read data from the specified slave's SII EEPROM. ",
        "input": "",
        "output": "SIIRead (int slaveId, int siiAddr, int len, EcSIIReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read data from the specified slave's SII EEPROM. ",
        "input": "",
        "output": "SIIRead (int masterId, int slaveId, int siiAddr, int len, EcSIIReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read AoE data from the specified slave.",
        "input": "",
        "output": "AoERead (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned char *readAoEBuff, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read AoE data from the specified slave.",
        "input": "",
        "output": "AoERead (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned char *readAoEBuff, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE data to the specified slave.",
        "input": "",
        "output": "AoEWrite (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE data to the specified slave.",
        "input": "",
        "output": "AoEWrite (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE control data to the specified slave.",
        "input": "",
        "output": "AoEWriteControl (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned short aoeState, unsigned short deviceState, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE control data to the specified slave.",
        "input": "",
        "output": "AoEWriteControl (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned short aoeState, unsigned short deviceState, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read and write AoE data from and to the specified slave.",
        "input": "",
        "output": "AoEReadWrite (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned char *readAoEBuff, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read and write AoE data from and to the specified slave.",
        "input": "",
        "output": "AoEReadWrite (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned char *readAoEBuff, unsigned int writeLength, unsigned char *writeAoEData, unsigned int *errCode, unsigned int waitTime=0, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read AoE data from the specified slave.",
        "input": "",
        "output": "AoERead (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, EcAoEReadCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read AoE data from the specified slave.",
        "input": "",
        "output": "AoERead (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, EcAoEReadCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE data to the specified slave. ",
        "input": "",
        "output": "AoEWrite (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int writeLength, unsigned char *writeAoEData, EcAoEWriteCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE data to the specified slave. ",
        "input": "",
        "output": "AoEWrite (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int writeLength, unsigned char *writeAoEData, EcAoEWriteCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE control data to the specified slave. ",
        "input": "",
        "output": "AoEWriteControl (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned short aoeState, unsigned short deviceState, unsigned int writeLength, unsigned char *writeAoEData, EcAoEWriteControlCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Write AoE control data to the specified slave. ",
        "input": "",
        "output": "AoEWriteControl (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned short aoeState, unsigned short deviceState, unsigned int writeLength, unsigned char *writeAoEData, EcAoEWriteControlCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read and write AoE data from and to the specified slave. ",
        "input": "",
        "output": "AoEReadWrite (int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned int writeLength, unsigned char *writeAoEData, EcAoEReadCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read and write AoE data from and to the specified slave. ",
        "input": "",
        "output": "AoEReadWrite (int masterId, int slaveId, unsigned char targetNetId[6], unsigned short targetPort, unsigned int indexGroup, unsigned int indexOffset, unsigned int readLength, unsigned int writeLength, unsigned char *writeAoEData, EcAoEReadCallBack callbackFunc, unsigned int waitTime, EcAoESender *sender=NULL)"
    },
    {
        "instruction": "Read SoE data from the specified slave. ",
        "input": "",
        "output": "SoERead (int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int buffSize, unsigned char *readSoEBuffer, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Read SoE data from the specified slave. ",
        "input": "",
        "output": "SoERead (int masterId, int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int buffSize, unsigned char *readSoEBuffer, unsigned int *actualSize, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Write SoE data to the specified slave.",
        "input": "",
        "output": "SoEWrite (int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int dataSize, unsigned char *writeSoEData, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Write SoE data to the specified slave.",
        "input": "",
        "output": "SoEWrite (int masterId, int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int dataSize, unsigned char *writeSoEData, unsigned int *errCode, unsigned int waitTime=0)"
    },
    {
        "instruction": "Read SoE data from the specified slave. ",
        "input": "",
        "output": "SoERead (int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, EcSoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read SoE data from the specified slave. ",
        "input": "",
        "output": "SoERead (int masterId, int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, EcSoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write SoE data to the specified slave. ",
        "input": "",
        "output": "SoEWrite (int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int dataSize, unsigned char *writeSoEData, EcSoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write SoE data to the specified slave. ",
        "input": "",
        "output": "SoEWrite (int masterId, int slaveId, unsigned char driveNo, unsigned char elementFlags, unsigned short idn, unsigned int dataSize, unsigned char *writeSoEData, EcSoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read VoE data from the specified slave.",
        "input": "",
        "output": "VoERead (int slaveId, unsigned int *vendorId, unsigned short *vendorType, unsigned int buffSize, unsigned char *readVoEBuffer, unsigned int *actualSize, unsigned int waitTime=0)"
    },
    {
        "instruction": "Read VoE data from the specified slave.",
        "input": "",
        "output": "VoERead (int masterId, int slaveId, unsigned int *vendorId, unsigned short *vendorType, unsigned int buffSize, unsigned char *readVoEBuffer, unsigned int *actualSize, unsigned int waitTime=0)"
    },
    {
        "instruction": "Write VoE data to the specified slave.",
        "input": "",
        "output": "VoEWrite (int slaveId, unsigned int vendorId, unsigned short vendorType, unsigned int dataSize, unsigned char *writeVoEData, unsigned int waitTime=0)"
    },
    {
        "instruction": "Write VoE data to the specified slave.",
        "input": "",
        "output": "VoEWrite (int masterId, int slaveId, unsigned int vendorId, unsigned short vendorType, unsigned int dataSize, unsigned char *writeVoEData, unsigned int waitTime=0)"
    },
    {
        "instruction": "Read VoE data from the specified slave. ",
        "input": "",
        "output": "VoERead (int slaveId, EcVoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Read VoE data from the specified slave. ",
        "input": "",
        "output": "VoERead (int masterId, int slaveId, EcVoEReadCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write VoE data to the specified slave.",
        "input": "",
        "output": "VoEWrite (int slaveId, unsigned int vendorId, unsigned short vendorType, unsigned int dataSize, unsigned char *writeVoEData, EcVoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Write VoE data to the specified slave.",
        "input": "",
        "output": "VoEWrite (int masterId, int slaveId, unsigned int vendorId, unsigned short vendorType, unsigned int dataSize, unsigned char *writeVoEData, EcVoEWriteCallBack callbackFunc, unsigned int waitTime)"
    },
    {
        "instruction": "Set the axis operation mode for a specified slave axis.",
        "input": "",
        "output": "SetAxisMode (int slaveId, int axisId, EcOperationMode::T mode)"
    },
    {
        "instruction": "Set the axis operation mode for a specified slave axis.",
        "input": "",
        "output": "SetAxisMode (int masterId, int slaveId, int axisId, EcOperationMode::T mode)"
    },
    {
        "instruction": "Start the PP operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisPP (int slaveId, int axisIndex, int targetPos, unsigned int profileVel, unsigned int profileAcc, unsigned int profileDec, char immediately=-1, char relative=-1)"
    },
    {
        "instruction": "Start the PP operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisPP (int masterId, int slaveId, int axisIndex, int targetPos, unsigned int profileVel, unsigned int profileAcc, unsigned int profileDec, char immediately=-1, char relative=-1)"
    },
    {
        "instruction": "Start the PV operation for a specified slave axis.",
        "input": "",
        "output": "StartAxisPV (int slaveId, int axisIndex, int targetVel, unsigned int profileAcc, unsigned int profileDec)"
    },
    {
        "instruction": "Start the PV operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisPV (int masterId, int slaveId, int axisIndex, int targetVel, unsigned int profileAcc, unsigned int profileDec)"
    },
    {
        "instruction": "Start the PV operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisPV (int slaveId, int axisIndex, int targetVel, unsigned int profileAcc, unsigned int profileDec, unsigned short maxTorque)"
    },
    {
        "instruction": "Start the PV operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisPV (int masterId, int slaveId, int axisIndex, int targetVel, unsigned int profileAcc, unsigned int profileDec, unsigned short maxTorque)"
    },
    {
        "instruction": "Start the TQ operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisTQ (int slaveId, int axisIndex, short targetTrq)"
    },
    {
        "instruction": "Start the TQ operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisTQ (int masterId, int slaveId, int axisIndex, short targetTrq)"
    },
    {
        "instruction": "Start the TQ operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisTQ (int slaveId, int axisIndex, short targetTrq, unsigned int maxMotorSpeed)"
    },
    {
        "instruction": "Start the TQ operation for a specified slave axis. ",
        "input": "",
        "output": "StartAxisTQ (int masterId, int slaveId, int axisIndex, short targetTrq, unsigned int maxMotorSpeed)"
    },
    {
        "instruction": "Start the HM operation for a specified slave axis.",
        "input": "",
        "output": "StartAxisHM (int slaveId, int axisIndex, int method, unsigned int switchSpeed, unsigned int zeroSpeed, unsigned int hmAcc)"
    },
    {
        "instruction": "Start the HM operation for a specified slave axis.",
        "input": "",
        "output": "StartAxisHM (int masterId, int slaveId, int axisIndex, int method, unsigned int switchSpeed, unsigned int zeroSpeed, unsigned int hmAcc)"
    },
    {
        "instruction": "Start the HM operation for a specified slave axis.",
        "input": "",
        "output": "StartAxisHM (int slaveId, int axisIndex, int method, unsigned int switchSpeed, unsigned int zeroSpeed, unsigned int hmAcc, int homeOffset)"
    },
    {
        "instruction": "Start the HM operation for a specified slave axis.",
        "input": "",
        "output": "StartAxisHM (int masterId, int slaveId, int axisIndex, int method, unsigned int switchSpeed, unsigned int zeroSpeed, unsigned int hmAcc, int homeOffset)"
    },
    {
        "instruction": "Halt the specified slave axis.",
        "input": "",
        "output": "HaltAxis (int slaveId, int axisIndex)"
    },
    {
        "instruction": "Halt the specified slave axis.",
        "input": "",
        "output": "HaltAxis (int masterId, int slaveId, int axisIndex)"
    },
    {
        "instruction": "Release the halt state for a specified slave axis.",
        "input": "",
        "output": "HaltAxisRelease (int slaveId, int axisIndex)"
    },
    {
        "instruction": "Release the halt state for a specified slave axis.",
        "input": "",
        "output": "HaltAxisRelease (int masterId, int slaveId, int axisIndex)"
    },
    {
        "instruction": "Open a serial channel to the specified slave.",
        "input": "",
        "output": "OpenSerialChannel (int slaveId, int chnlId, wchar_t *comName, DCB *dcb, COMMTIMEOUTS *timeout, unsigned int *error=NULL)"
    },
    {
        "instruction": "Open a serial channel to the specified slave.",
        "input": "",
        "output": "OpenSerialChannel (int masterId, int slaveId, int chnlId, wchar_t *comName, DCB *dcb, COMMTIMEOUTS *timeout, unsigned int *error=NULL)"
    },
    {
        "instruction": "Open a serial channel to the specified slave.",
        "input": "",
        "output": "OpenSerialChannel (int slaveId, int chnlId, char *comName, DCB *dcb, COMMTIMEOUTS *timeout, unsigned int *error=NULL)"
    },
    {
        "instruction": "Open a serial channel to the specified slave.",
        "input": "",
        "output": "OpenSerialChannel (int masterId, int slaveId, int chnlId, char *comName, DCB *dcb, COMMTIMEOUTS *timeout, unsigned int *error=NULL)"
    },
    {
        "instruction": "Close an opened serial channel for the specified slave.",
        "input": "",
        "output": "CloseSerialChannel (int slaveId, int chnlId)"
    },
    {
        "instruction": "Close an opened serial channel for the specified slave.",
        "input": "",
        "output": "CloseSerialChannel (int masterId, int slaveId, int chnlId)"
    },
    {
        "instruction": "Get a string representation of the specified error code. ",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log.",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the library version information of EcApi.lib.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Constructor to initialize an object of this class. The device created by the WMX3Api object passed to this constructor is used to execute API functions. Also see Devices. ",
        "input": "",
        "output": "PMMotion (WMX3Api *f)"
    },
    {
        "instruction": "Copy constructor to initialize an object of this class based on an existing object of this class. Also see Copy Operators. ",
        "input": "",
        "output": "PMMotion (const PMMotion &src)"
    },
    {
        "instruction": "Copy assignment operator to initialize an object of this class based on an existing object of this class. Also see Copy Operators. ",
        "input": "",
        "output": "PMMotion & operator= (const PMMotion &src)"
    },
    {
        "instruction": "Constructor to initialize an object of this class with a self device. Also see Self Devices. ",
        "input": "",
        "output": "PMMotion ()"
    },
    {
        "instruction": "Destructor for this class. ",
        "input": "",
        "output": "~PMMotion ()"
    },
    {
        "instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "input": "",
        "output": "IsDeviceValid ()"
    },
    {
        "instruction": "Get the version of the module rtdll. ",
        "input": "",
        "output": "GetVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "Read the system status of PM motion from the engine. ",
        "input": "",
        "output": "GetStatus (PMMotionStatus *status)"
    },
    {
        "instruction": "Get a string representation of the specified error code.",
        "input": "",
        "output": "ErrorToString (int errCode, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the specified error code. ",
        "input": "",
        "output": "ErrorToString (int errCode, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log. ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, char *pString, unsigned int size)"
    },
    {
        "instruction": "Get a string representation of the raw data of an API log. ",
        "input": "",
        "output": "ApiLogToString (unsigned char *pLogData, unsigned int logDataSize, wchar_t *pString, unsigned int size)"
    },
    {
        "instruction": "Get the version of the module library.",
        "input": "",
        "output": "GetLibVersion (int *pMajorVersion, int *pMinorVersion, int *pRevisionVersion, int *pFixVersion)"
    },
    {
        "instruction": "This class contains axis control functions for PM motion. ",
        "input": "",
        "output": "PMAxisControl (PMMotion *f)"
    },
    {
        "instruction": "This class contains profile data for a home command.",
        "input": "",
        "output": "HomeProfile"
    },
    {
        "instruction": "This class contains profile data for multiple home commands.",
        "input": "",
        "output": "HomeProfiles"
    },
    {
        "instruction": "This class contains profile data for a torque command. ",
        "input": "",
        "output": "TorqueProfile"
    },
    {
        "instruction": "This class contains profile data for multiple torque commands.",
        "input": "",
        "output": "TorqueProfiles"
    },
    {
        "instruction": "This class contains profile data for a velocity command. ",
        "input": "",
        "output": "VelocityProfile"
    },
    {
        "instruction": "This class contains profile data for multiple velocity commands. ",
        "input": "",
        "output": "VelocityProfiles"
    },
    {
        "instruction": "Turn a servo drive in the servo network on or off.",
        "input": "",
        "output": "SetServoOn (int axis, int newStatus)"
    },
    {
        "instruction": "Turn multiple servo drives in the servo network on or off. ",
        "input": "",
        "output": "SetServoOn (AxisSelection *axisSel, int newStatus)"
    },
    {
        "instruction": "Clear the servo drive amp alarm on the specified axis.",
        "input": "",
        "output": "ClearAmpAlarm (int axis)"
    },
    {
        "instruction": "Clear the servo drive amp alarms on multiple axes.",
        "input": "",
        "output": "ClearAmpAlarm (AxisSelection *axisSel)"
    },
    {
        "instruction": "Set the home profile. ",
        "input": "",
        "output": "SetHomeProfile (HomeProfile *pHomeProfile)"
    },
    {
        "instruction": "Set the home profile for multiple axes. ",
        "input": "",
        "output": "SetHomeProfiles (HomeProfiles *pHomeProfiles)"
    },
    {
        "instruction": "Set the velocity profile.",
        "input": "",
        "output": "SetVelProfile (VelocityProfile *pVelProfile)"
    },
    {
        "instruction": "Set the velocity profile for multiple axes. ",
        "input": "",
        "output": "SetVelProfiles (VelocityProfiles *pVelProfiles)"
    },
    {
        "instruction": "Set the torque profile. ",
        "input": "",
        "output": "SetTrqProfile (TorqueProfile *pTrqProfile)"
    },
    {
        "instruction": "Set the torque profile for multiple axes",
        "input": "",
        "output": "SetTrqProfiles (TorqueProfiles *pTrqProfiles)"
    },
    {
        "instruction": "Get the current cycle position command of the axis.",
        "input": "",
        "output": "GetPosCommand (int axis, long *pPosition)"
    },
    {
        "instruction": "Get the current cycle position feedback of the axis.",
        "input": "",
        "output": "GetPosFeedback (int axis, long *pPosition)"
    },
    {
        "instruction": "Get the current cycle velocity command of the axis. ",
        "input": "",
        "output": "GetVelCommand (int axis, long *pVelocity)"
    },
    {
        "instruction": "Get the current cycle velocity feedback of the axis. ",
        "input": "",
        "output": "GetVelFeedback (int axis, long *pVelocity)"
    },
    {
        "instruction": "This class contains HM mode homing functions for PM motion. ",
        "input": "",
        "output": "PMAxisHome (PMMotion *f)"
    },
    {
        "instruction": "This class contains data for a home command.",
        "input": "",
        "output": "HomeCommand"
    },
    {
        "instruction": "Start HM mode homing.",
        "input": "",
        "output": "StartHome (int axis)"
    },
    {
        "instruction": "Start HM mode homing.",
        "input": "",
        "output": "StartHome (HomeCommand *pHomeCommand)"
    },
    {
        "instruction": "Start HM mode homing for multiple axes.",
        "input": "",
        "output": "StartHome (unsigned int numCommands, HomeCommand *pHomeCommand)"
    },
    {
        "instruction": "Resume HM mode homing for an axis that has been stopped. ",
        "input": "",
        "output": "Continue (int axis)"
    },
    {
        "instruction": "Resume HM mode homing for multiple axes that have been stopped.",
        "input": "",
        "output": "Continue (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Stop HM mode homing.",
        "input": "",
        "output": "Cancel (int axis)"
    },
    {
        "instruction": "Stop HM mode homing for multiple axes.",
        "input": "",
        "output": "Cancel (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "This class contains PP mode position command functions for PM motion.",
        "input": "",
        "output": "PMAxisMotion (PMMotion *f)"
    },
    {
        "instruction": "Start an absolute position PP mode motion command.",
        "input": "",
        "output": "StartPos (int axis, long target, bool immediately=true)"
    },
    {
        "instruction": "Start a relative position PP mode motion command.",
        "input": "",
        "output": "StartMov (int axis, long target, bool immediately=true)"
    },
    {
        "instruction": "Start an absolute position PP mode motion command. ",
        "input": "",
        "output": "StartPos (int axis, long target, long maxTrqLimit, bool immediately=true)"
    },
    {
        "instruction": "Start a relative position PP mode motion command.",
        "input": "",
        "output": "StartMov (int axis, long target, long maxTrqLimit, bool immediately=true)"
    },
    {
        "instruction": "Start an absolute position PP mode motion command.",
        "input": "",
        "output": "StartPos (PosCommand *pPosCommand, bool immediately=true)"
    },
    {
        "instruction": "Start a relative position PP mode motion command. ",
        "input": "",
        "output": "StartMov (PosCommand *pPosCommand, bool immediately=true)"
    },
    {
        "instruction": "Start an absolute position PP mode motion command. ",
        "input": "",
        "output": "StartPos (PosCommand *pPosCommand, long maxTrqLimit, bool immediately=true)"
    },
    {
        "instruction": "Start a relative position PP mode motion command. ",
        "input": "",
        "output": "StartMov (PosCommand *pPosCommand, long maxTrqLimit, bool immediately=true)"
    },
    {
        "instruction": "Start absolute position PP mode motion commands for multiple axes. ",
        "input": "",
        "output": "StartPos (unsigned int numCommands, PosCommand *pPosCommand, bool immediately=true)"
    },
    {
        "instruction": "Start relative position PP mode motion commands for multiple axes. ",
        "input": "",
        "output": "StartMov (unsigned int numCommands, PosCommand *pPosCommand, bool immediately=true)"
    },
    {
        "instruction": "Start absolute position PP mode motion commands for multiple axes. ",
        "input": "",
        "output": "StartPos (unsigned int numCommands, PosCommand *pPosCommand, long *maxTrqLimits, bool immediately=true)"
    },
    {
        "instruction": "Start relative position PP mode motion commands for multiple axes. ",
        "input": "",
        "output": "StartMov (unsigned int numCommands, PosCommand *pPosCommand, long *maxTrqLimits, bool immediately=true)"
    },
    {
        "instruction": "Stop the motion of an axis executing a PP mode position command.",
        "input": "",
        "output": "Stop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes executing PP mode position commands.",
        "input": "",
        "output": "Stop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Pause the execution of a PP mode position command. ",
        "input": "",
        "output": "Pause (int axis)"
    },
    {
        "instruction": "Pause the execution of PP mode position commands for multiple axes. ",
        "input": "",
        "output": "Pause (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "Resume the execution of a paused PP mode position command. ",
        "input": "",
        "output": "Resume (int axis)"
    },
    {
        "instruction": "Resume the execution of paused PP mode position commands for multiple axes.",
        "input": "",
        "output": "Resume (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "This class contains PV mode velocity command functions for PM motion. ",
        "input": "",
        "output": "PMAxisVelocity (PMMotion *f)"
    },
    {
        "instruction": "This class contains data for a velocity command.",
        "input": "",
        "output": "VelCommand"
    },
    {
        "instruction": "Start a PV mode velocity command. ",
        "input": "",
        "output": "StartVel (int axis)"
    },
    {
        "instruction": "Start a PV mode velocity command. ",
        "input": "",
        "output": "StartVel (int axis, long maxTrqLimit)"
    },
    {
        "instruction": "Start a PV mode velocity command. ",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand)"
    },
    {
        "instruction": "Start a PV mode velocity command and set the maximum torque limit. ",
        "input": "",
        "output": "StartVel (VelCommand *pVelCommand, long maxTrqLimit)"
    },
    {
        "instruction": "Start PV mode velocity commands for multiple axes.",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand)"
    },
    {
        "instruction": "Start PV mode velocity commands for multiple axes. ",
        "input": "",
        "output": "StartVel (unsigned int numCommands, VelCommand *pVelCommand, long *maxTrqLimits)"
    },
    {
        "instruction": "Stop the motion of an axis executing a PV mode velocity command. ",
        "input": "",
        "output": "Stop (int axis)"
    },
    {
        "instruction": "Stop the motion of multiple axes executing PV mode velocity commands.",
        "input": "",
        "output": "Stop (AxisSelection *pAxisSelection)"
    },
    {
        "instruction": "This class contains TQ mode torque command functions for PM motion. ",
        "input": "",
        "output": "PMAxisTorque (PMMotion *f)"
    },
    {
        "instruction": "Start a TQ mode torque command. ",
        "input": "",
        "output": "StartTrq (int axis)"
    },
    {
        "instruction": "Start a TQ mode torque command. ",
        "input": "",
        "output": "StartTrq (int axis, long maxMotorSpeed)"
    },
    {
        "instruction": "Start a TQ mode torque command. ",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start a TQ mode torque command and set the maximum motor speed. ",
        "input": "",
        "output": "StartTrq (TrqCommand *pTrqCommand, long maxMotorSpeed)"
    },
    {
        "instruction": "Start TQ mode torque commands for multiple axes.",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand)"
    },
    {
        "instruction": "Start TQ mode torque commands for multiple axes. ",
        "input": "",
        "output": "StartTrq (unsigned int numCommands, TrqCommand *pTrqCommand, long *maxMotorSpeeds)"
    },
    {
        "instruction": "Stop a TQ mode torque command. ",
        "input": "",
        "output": "StopTrq (int axis)"
    },
    {
        "instruction": "Stop TQ mode torque commands for multiple axes.",
        "input": "",
        "output": "StopTrq (AxisSelection *pAxisSelection)"
    }
]